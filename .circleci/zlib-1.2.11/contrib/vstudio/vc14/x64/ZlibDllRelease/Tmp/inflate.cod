; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31107.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+10
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateCodesUsed
PUBLIC	inflateMark
PUBLIC	inflateValidate
PUBLIC	inflateUndermine
PUBLIC	inflateCopy
PUBLIC	inflateSyncPoint
PUBLIC	inflateSync
PUBLIC	inflateGetHeader
PUBLIC	inflateSetDictionary
PUBLIC	inflateGetDictionary
PUBLIC	inflatePrime
PUBLIC	inflateInit_
PUBLIC	inflateReset2
PUBLIC	inflateResetKeep
PUBLIC	inflateEnd
PUBLIC	inflate
PUBLIC	inflateInit2_
PUBLIC	inflateReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCodesUsed DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$inflateCodesUsed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateMark DD imagerel $LN9
	DD	imagerel $LN9+108
	DD	imagerel $unwind$inflateMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateValidate DD imagerel $LN7
	DD	imagerel $LN7+57
	DD	imagerel $unwind$inflateValidate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateUndermine DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$inflateUndermine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN19
	DD	imagerel $LN19+48
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateCopy DD imagerel $LN19+48
	DD	imagerel $LN19+92
	DD	imagerel $chain$2$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateCopy DD imagerel $LN19+92
	DD	imagerel $LN19+161
	DD	imagerel $chain$4$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateCopy DD imagerel $LN19+161
	DD	imagerel $LN19+183
	DD	imagerel $chain$5$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$inflateCopy DD imagerel $LN19+183
	DD	imagerel $LN19+417
	DD	imagerel $chain$7$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$inflateCopy DD imagerel $LN19+417
	DD	imagerel $LN19+429
	DD	imagerel $chain$8$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSyncPoint DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$inflateSyncPoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN20
	DD	imagerel $LN20+33
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateSync DD imagerel $LN20+33
	DD	imagerel $LN20+66
	DD	imagerel $chain$0$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateSync DD imagerel $LN20+66
	DD	imagerel $LN20+285
	DD	imagerel $chain$4$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+101
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetHeader DD imagerel $LN8
	DD	imagerel $LN8+51
	DD	imagerel $unwind$inflateGetHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN13
	DD	imagerel $LN13+184
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetDictionary DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$inflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+266
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflatePrime DD imagerel $LN9
	DD	imagerel $LN9+96
	DD	imagerel $unwind$inflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN13
	DD	imagerel $LN13+147
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateResetKeep DD imagerel $LN6
	DD	imagerel $LN6+138
	DD	imagerel $unwind$inflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN7
	DD	imagerel $LN7+96
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN980
	DD	imagerel $LN980+6148
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateInit2_ DD imagerel $LN14+67
	DD	imagerel $LN14+173
	DD	imagerel $chain$1$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateInit2_ DD imagerel $LN14+173
	DD	imagerel $LN14+225
	DD	imagerel $chain$3$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateInit2_ DD imagerel $LN14+225
	DD	imagerel $LN14+241
	DD	imagerel $chain$4$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset DD imagerel $LN5
	DD	imagerel $LN5+45
	DD	imagerel $unwind$inflateReset
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateInit2_ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateInit2_ DD 040021H
	DD	077400H
	DD	065400H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateInit2_ DD 040c21H
	DD	07740cH
	DD	065405H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 0a1801H
	DD	0123418H
	DD	0f0149218H
	DD	0d010e012H
	DD	0700cc00eH
	DD	0500a600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 062b01H
	DD	07742bH
	DD	066426H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateResetKeep DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflatePrime DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 0a6401H
	DD	09f464H
	DD	08745cH
	DD	0a340dH
	DD	0e009320dH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetDictionary DD 062e01H
	DD	06342eH
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetHeader DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateSync DD 061121H
	DD	085411H
	DD	06340cH
	DD	096400H
	DD	imagerel $LN20
	DD	imagerel $LN20+33
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateSync DD 020521H
	DD	096405H
	DD	imagerel $LN20
	DD	imagerel $LN20+33
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSyncPoint DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$inflateCopy DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+48
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$inflateCopy DD 0a0021H
	DD	04f400H
	DD	0be400H
	DD	0ac400H
	DD	096400H
	DD	083400H
	DD	imagerel $LN19
	DD	imagerel $LN19+48
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateCopy DD 021H
	DD	imagerel $LN19+48
	DD	imagerel $LN19+92
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateCopy DD 040a21H
	DD	04f40aH
	DD	0ac405H
	DD	imagerel $LN19+48
	DD	imagerel $LN19+92
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateCopy DD 061321H
	DD	0be413H
	DD	09640aH
	DD	083405H
	DD	imagerel $LN19
	DD	imagerel $LN19+48
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 030701H
	DD	070034207H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateUndermine DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateValidate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateMark DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCodesUsed DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateReset
_TEXT	SEGMENT
strm$ = 48
inflateReset PROC					; COMDAT

; 146  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateRes
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 155  : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateRes:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 151  :     state->wsize = 0;

  0001b	33 d2		 xor	 edx, edx
  0001d	48 89 50 34	 mov	 QWORD PTR [rax+52], rdx

; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;

  00021	89 50 3c	 mov	 DWORD PTR [rax+60], edx

; 155  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 154  :     return inflateResetKeep(strm);

  00028	e9 00 00 00 00	 jmp	 inflateResetKeep
inflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateInit2_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
version$ = 64
stream_size$ = 72
inflateInit2_ PROC					; COMDAT

; 200  : {

$LN14:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b f2		 mov	 esi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  0000f	4d 85 c0	 test	 r8, r8
  00012	0f 84 c9 00 00
	00		 je	 $LN3@inflateIni
  00018	41 80 38 31	 cmp	 BYTE PTR [r8], 49	; 00000031H
  0001c	0f 85 bf 00 00
	00		 jne	 $LN3@inflateIni
  00022	41 83 f9 58	 cmp	 r9d, 88			; 00000058H
  00026	0f 85 b5 00 00
	00		 jne	 $LN3@inflateIni

; 205  :         stream_size != (int)(sizeof(z_stream)))
; 206  :         return Z_VERSION_ERROR;
; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002c	48 85 c9	 test	 rcx, rcx
  0002f	75 0e		 jne	 SHORT $LN4@inflateIni
  00031	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 237  : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5e		 pop	 rsi
  0003e	c3		 ret	 0
$LN4@inflateIni:

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 209  :     if (strm->zalloc == (alloc_func)0) {

  0003f	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00043	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00048	33 ed		 xor	 ebp, ebp
  0004a	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004f	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp
  00053	48 85 c0	 test	 rax, rax
  00056	75 13		 jne	 SHORT $LN10@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;

  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 214  :         strm->opaque = (voidpf)0;

  0005f	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00063	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  00067	8b cd		 mov	 ecx, ebp
  00069	eb 04		 jmp	 SHORT $LN5@inflateIni
$LN10@inflateIni:
  0006b	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
$LN5@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  0006f	48 39 6b 38	 cmp	 QWORD PTR [rbx+56], rbp
  00073	75 0b		 jne	 SHORT $LN6@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zcfree
  0007c	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN6@inflateIni:

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)

  00080	ba 01 00 00 00	 mov	 edx, 1
  00085	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  0008b	ff d0		 call	 rax
  0008d	48 8b f8	 mov	 rdi, rax

; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00090	48 85 c0	 test	 rax, rax
  00093	75 18		 jne	 SHORT $LN7@inflateIni
  00095	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
$LN12@inflateIni:
  00098	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0009d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 237  : }

  000a2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5e		 pop	 rsi
  000ac	c3		 ret	 0
$LN7@inflateIni:

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;

  000ad	48 89 7b 28	 mov	 QWORD PTR [rbx+40], rdi

; 228  :     state->strm = strm;
; 229  :     state->window = Z_NULL;
; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 231  :     ret = inflateReset2(strm, windowBits);

  000b1	8b d6		 mov	 edx, esi
  000b3	48 8b cb	 mov	 rcx, rbx
  000b6	48 89 18	 mov	 QWORD PTR [rax], rbx
  000b9	48 89 68 40	 mov	 QWORD PTR [rax+64], rbp
  000bd	c7 40 08 34 3f
	00 00		 mov	 DWORD PTR [rax+8], 16180 ; 00003f34H
  000c4	e8 00 00 00 00	 call	 inflateReset2
  000c9	8b f0		 mov	 esi, eax

; 232  :     if (ret != Z_OK) {

  000cb	85 c0		 test	 eax, eax
  000cd	74 0e		 je	 SHORT $LN8@inflateIni

; 233  :         ZFREE(strm, state);

  000cf	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000d3	48 8b d7	 mov	 rdx, rdi
  000d6	ff 53 38	 call	 QWORD PTR [rbx+56]

; 234  :         strm->state = Z_NULL;

  000d9	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp
$LN8@inflateIni:

; 235  :     }
; 236  :     return ret;

  000dd	8b c6		 mov	 eax, esi
  000df	eb b7		 jmp	 SHORT $LN12@inflateIni
$LN3@inflateIni:

; 237  : }

  000e1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e6	b8 fa ff ff ff	 mov	 eax, -6
  000eb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ef	5e		 pop	 rsi
  000f0	c3		 ret	 0
inflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflate
_TEXT	SEGMENT
left$1$ = 48
hbuf$ = 52
here$ = 56
in$1$ = 60
put$1$ = 64
strm$ = 144
flush$ = 152
out$1$ = 160
ret$1$ = 168
inflate	PROC						; COMDAT

; 625  : {

$LN980:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	55		 push	 rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	4c 8b e1	 mov	 r12, rcx

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  0001b	e8 00 00 00 00	 call	 inflateStateCheck
  00020	85 c0		 test	 eax, eax
  00022	0f 85 3e 17 00
	00		 jne	 $LN333@inflate
  00028	48 83 79 10 00	 cmp	 QWORD PTR [rcx+16], 0
  0002d	0f 84 33 17 00
	00		 je	 $LN333@inflate
  00033	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00037	75 09		 jne	 SHORT $LN721@inflate
  00039	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  0003c	0f 85 24 17 00
	00		 jne	 $LN333@inflate
$LN721@inflate:

; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  00042	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00046	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  0004a	3d 3f 3f 00 00	 cmp	 eax, 16191		; 00003f3fH
  0004f	75 0d		 jne	 SHORT $LN4@inflate
  00051	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H
  00059	b8 40 3f 00 00	 mov	 eax, 16192		; 00003f40H
$LN4@inflate:

; 651  :     LOAD();

  0005e	44 8b 59 18	 mov	 r11d, DWORD PTR [rcx+24]

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;

  00062	45 33 ff	 xor	 r15d, r15d
  00065	4c 8b 51 10	 mov	 r10, QWORD PTR [rcx+16]

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00069	05 cc c0 ff ff	 add	 eax, -16180		; ffffffffffffc0ccH
  0006e	8b 71 08	 mov	 esi, DWORD PTR [rcx+8]
  00071	45 8b c3	 mov	 r8d, r11d
  00074	48 8b 29	 mov	 rbp, QWORD PTR [rcx]
  00077	45 8b 75 48	 mov	 r14d, DWORD PTR [r13+72]
  0007b	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  0007f	4c 89 54 24 40	 mov	 QWORD PTR put$1$[rsp], r10
  00084	44 89 5c 24 30	 mov	 DWORD PTR left$1$[rsp], r11d
  00089	89 74 24 3c	 mov	 DWORD PTR in$1$[rsp], esi
  0008d	44 89 9c 24 a0
	00 00 00	 mov	 DWORD PTR out$1$[rsp], r11d
  00095	44 89 bc 24 a8
	00 00 00	 mov	 DWORD PTR ret$1$[rsp], r15d
  0009d	83 f8 1f	 cmp	 eax, 31
  000a0	0f 87 c0 16 00
	00		 ja	 $LN333@inflate
$LN976@inflate:
  000a6	48 98		 cdqe
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000af	4d 8d 4d 74	 lea	 r9, QWORD PTR [r13+116]
  000b3	49 8d 7d 70	 lea	 rdi, QWORD PTR [r13+112]
  000b7	8b 8c 81 00 00
	00 00		 mov	 ecx, DWORD PTR $LN820@inflate[rcx+rax*4]
  000be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  000c5	48 03 c8	 add	 rcx, rax
  000c8	ff e1		 jmp	 rcx
$LN335@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  000ca	41 8b 55 10	 mov	 edx, DWORD PTR [r13+16]
  000ce	85 d2		 test	 edx, edx
  000d0	75 0d		 jne	 SHORT $LN12@inflate

; 659  :                 state->mode = TYPEDO;

  000d2	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H

; 660  :                 break;

  000da	e9 92 06 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  000df	83 fb 10	 cmp	 ebx, 16
  000e2	73 20		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000e4	85 f6		 test	 esi, esi
  000e6	0f 84 1b 08 00
	00		 je	 $LN938@inflate
  000ec	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  000f0	8b cb		 mov	 ecx, ebx
  000f2	d3 e0		 shl	 eax, cl
  000f4	ff ce		 dec	 esi
  000f6	44 03 f0	 add	 r14d, eax
  000f9	48 ff c5	 inc	 rbp
  000fc	83 c3 08	 add	 ebx, 8
  000ff	83 fb 10	 cmp	 ebx, 16
  00102	72 e0		 jb	 SHORT $LL13@inflate
$LN10@inflate:

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00104	f6 c2 02	 test	 dl, 2
  00107	74 5f		 je	 SHORT $LN338@inflate
  00109	41 81 fe 1f 8b
	00 00		 cmp	 r14d, 35615		; 00008b1fH
  00110	75 56		 jne	 SHORT $LN338@inflate

; 665  :                 if (state->wbits == 0)

  00112	41 83 7d 30 00	 cmp	 DWORD PTR [r13+48], 0
  00117	75 08		 jne	 SHORT $LN339@inflate

; 666  :                     state->wbits = 15;

  00119	41 c7 45 30 0f
	00 00 00	 mov	 DWORD PTR [r13+48], 15
$LN339@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  00121	45 33 c0	 xor	 r8d, r8d
  00124	33 d2		 xor	 edx, edx
  00126	33 c9		 xor	 ecx, ecx
  00128	e8 00 00 00 00	 call	 crc32

; 668  :                 CRC2(state->check, hold);

  0012d	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  00132	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00137	41 c1 ee 08	 shr	 r14d, 8
  0013b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00141	8b c8		 mov	 ecx, eax
  00143	44 88 74 24 35	 mov	 BYTE PTR hbuf$[rsp+1], r14b
  00148	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  0014c	e8 00 00 00 00	 call	 crc32
  00151	41 89 45 20	 mov	 DWORD PTR [r13+32], eax

; 669  :                 INITBITS();

  00155	45 8b f7	 mov	 r14d, r15d
  00158	41 8b df	 mov	 ebx, r15d

; 670  :                 state->mode = FLAGS;

  0015b	41 c7 45 08 35
	3f 00 00	 mov	 DWORD PTR [r13+8], 16181 ; 00003f35H

; 671  :                 break;

  00163	e9 ff 05 00 00	 jmp	 $LN975@inflate
$LN338@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */
; 674  :             if (state->head != Z_NULL)

  00168	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0016c	45 89 7d 18	 mov	 DWORD PTR [r13+24], r15d
  00170	48 85 c0	 test	 rax, rax
  00173	74 07		 je	 SHORT $LN340@inflate

; 675  :                 state->head->done = -1;

  00175	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN340@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  0017c	41 f6 45 10 01	 test	 BYTE PTR [r13+16], 1
  00181	0f 84 cf 00 00
	00		 je	 $LN342@inflate
  00187	41 0f b6 ce	 movzx	 ecx, r14b
  0018b	41 8b c6	 mov	 eax, r14d
  0018e	c1 e8 08	 shr	 eax, 8
  00191	c1 e1 08	 shl	 ecx, 8
  00194	03 c8		 add	 ecx, eax
  00196	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  0019b	f7 e1		 mul	 ecx
  0019d	8b c1		 mov	 eax, ecx
  0019f	2b c2		 sub	 eax, edx
  001a1	d1 e8		 shr	 eax, 1
  001a3	03 c2		 add	 eax, edx
  001a5	c1 e8 04	 shr	 eax, 4
  001a8	6b c0 1f	 imul	 eax, eax, 31
  001ab	3b c8		 cmp	 ecx, eax
  001ad	0f 85 a3 00 00
	00		 jne	 $LN342@inflate

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  001b3	41 8b c6	 mov	 eax, r14d
  001b6	24 0f		 and	 al, 15
  001b8	3c 08		 cmp	 al, 8
  001ba	74 19		 je	 SHORT $LN26@inflate

; 686  :                 strm->msg = (char *)"unknown compression method";

  001bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  001c3	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 687  :                 state->mode = BAD;

  001c8	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 688  :                 break;

  001d0	e9 9c 05 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 689  :             }
; 690  :             DROPBITS(4);
; 691  :             len = BITS(4) + 8;
; 692  :             if (state->wbits == 0)

  001d5	41 8b 45 30	 mov	 eax, DWORD PTR [r13+48]
  001d9	83 c3 fc	 add	 ebx, -4			; fffffffcH
  001dc	41 c1 ee 04	 shr	 r14d, 4
  001e0	41 8b ce	 mov	 ecx, r14d
  001e3	83 e1 0f	 and	 ecx, 15
  001e6	83 c1 08	 add	 ecx, 8
  001e9	85 c0		 test	 eax, eax
  001eb	75 06		 jne	 SHORT $LN344@inflate

; 693  :                 state->wbits = len;

  001ed	41 89 4d 30	 mov	 DWORD PTR [r13+48], ecx
  001f1	8b c1		 mov	 eax, ecx
$LN344@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  001f3	83 f9 0f	 cmp	 ecx, 15
  001f6	77 45		 ja	 SHORT $LN346@inflate
  001f8	3b c8		 cmp	 ecx, eax
  001fa	77 41		 ja	 SHORT $LN346@inflate

; 698  :             }
; 699  :             state->dmax = 1U << len;

  001fc	b8 01 00 00 00	 mov	 eax, 1

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00201	45 33 c0	 xor	 r8d, r8d
  00204	d3 e0		 shl	 eax, cl
  00206	33 d2		 xor	 edx, edx
  00208	33 c9		 xor	 ecx, ecx
  0020a	41 89 45 1c	 mov	 DWORD PTR [r13+28], eax
  0020e	e8 00 00 00 00	 call	 adler32

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00213	41 c1 ee 08	 shr	 r14d, 8

; 703  :             INITBITS();

  00217	41 8b df	 mov	 ebx, r15d
  0021a	41 f7 d6	 not	 r14d
  0021d	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00221	41 83 e6 02	 and	 r14d, 2
  00225	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
  0022a	41 81 ce 3d 3f
	00 00		 or	 r14d, 16189		; 00003f3dH
  00231	45 89 75 08	 mov	 DWORD PTR [r13+8], r14d
  00235	45 8b f7	 mov	 r14d, r15d

; 704  :             break;

  00238	e9 2a 05 00 00	 jmp	 $LN975@inflate
$LN346@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  0023d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size@
  00244	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 696  :                 state->mode = BAD;

  00249	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 697  :                 break;

  00251	e9 1b 05 00 00	 jmp	 $LN8@inflate
$LN342@inflate:

; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 681  :                 strm->msg = (char *)"incorrect header check";

  00256	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
  0025d	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 682  :                 state->mode = BAD;

  00262	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 683  :                 break;

  0026a	e9 02 05 00 00	 jmp	 $LN8@inflate
$LN32@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  0026f	83 fb 10	 cmp	 ebx, 16
  00272	73 20		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00274	85 f6		 test	 esi, esi
  00276	0f 84 8b 06 00
	00		 je	 $LN938@inflate
  0027c	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00280	8b cb		 mov	 ecx, ebx
  00282	d3 e0		 shl	 eax, cl
  00284	ff ce		 dec	 esi
  00286	44 03 f0	 add	 r14d, eax
  00289	48 ff c5	 inc	 rbp
  0028c	83 c3 08	 add	 ebx, 8
  0028f	83 fb 10	 cmp	 ebx, 16
  00292	72 e0		 jb	 SHORT $LL33@inflate
$LN30@inflate:

; 708  :             state->flags = (int)(hold);

  00294	45 89 75 18	 mov	 DWORD PTR [r13+24], r14d

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00298	41 80 fe 08	 cmp	 r14b, 8
  0029c	74 19		 je	 SHORT $LN349@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";

  0029e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  002a5	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 711  :                 state->mode = BAD;

  002aa	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 712  :                 break;

  002b2	e9 ba 04 00 00	 jmp	 $LN8@inflate
$LN349@inflate:

; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  002b7	41 f7 c6 00 e0
	00 00		 test	 r14d, 57344		; 0000e000H
  002be	74 19		 je	 SHORT $LN350@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  002c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
  002c7	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 716  :                 state->mode = BAD;

  002cc	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 717  :                 break;

  002d4	e9 98 04 00 00	 jmp	 $LN8@inflate
$LN350@inflate:

; 718  :             }
; 719  :             if (state->head != Z_NULL)

  002d9	49 8b 55 28	 mov	 rdx, QWORD PTR [r13+40]
  002dd	41 8b ce	 mov	 ecx, r14d
  002e0	c1 e9 08	 shr	 ecx, 8
  002e3	48 85 d2	 test	 rdx, rdx
  002e6	74 07		 je	 SHORT $LN654@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  002e8	8b c1		 mov	 eax, ecx
  002ea	83 e0 01	 and	 eax, 1
  002ed	89 02		 mov	 DWORD PTR [rdx], eax
$LN654@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002ef	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  002f7	74 28		 je	 SHORT $LN39@inflate
  002f9	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  002fe	74 21		 je	 SHORT $LN39@inflate

; 722  :                 CRC2(state->check, hold);

  00300	88 4c 24 35	 mov	 BYTE PTR hbuf$[rsp+1], cl
  00304	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00309	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0030d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00313	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  00318	e8 00 00 00 00	 call	 crc32
  0031d	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN39@inflate:

; 723  :             INITBITS();

  00321	45 8b f7	 mov	 r14d, r15d

; 724  :             state->mode = TIME;

  00324	41 c7 45 08 36
	3f 00 00	 mov	 DWORD PTR [r13+8], 16182 ; 00003f36H
  0032c	41 8b df	 mov	 ebx, r15d

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  0032f	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  00331	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00334	73 20		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  00336	85 f6		 test	 esi, esi
  00338	0f 84 c9 05 00
	00		 je	 $LN938@inflate
  0033e	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00342	8b cb		 mov	 ecx, ebx
  00344	d3 e0		 shl	 eax, cl
  00346	ff ce		 dec	 esi
  00348	44 03 f0	 add	 r14d, eax
  0034b	48 ff c5	 inc	 rbp
  0034e	83 c3 08	 add	 ebx, 8
  00351	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00354	72 e0		 jb	 SHORT $LL47@inflate
$LN44@inflate:

; 727  :             if (state->head != Z_NULL)

  00356	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0035a	48 85 c0	 test	 rax, rax
  0035d	74 04		 je	 SHORT $LN355@inflate

; 728  :                 state->head->time = hold;

  0035f	44 89 70 04	 mov	 DWORD PTR [rax+4], r14d
$LN355@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00363	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  0036b	74 41		 je	 SHORT $LN53@inflate
  0036d	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00372	74 3a		 je	 SHORT $LN53@inflate

; 730  :                 CRC4(state->check, hold);

  00374	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00378	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0037d	41 8b c6	 mov	 eax, r14d
  00380	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  00385	c1 e8 08	 shr	 eax, 8
  00388	41 b8 04 00 00
	00		 mov	 r8d, 4
  0038e	88 44 24 35	 mov	 BYTE PTR hbuf$[rsp+1], al
  00392	41 8b c6	 mov	 eax, r14d
  00395	c1 e8 10	 shr	 eax, 16
  00398	41 c1 ee 18	 shr	 r14d, 24
  0039c	88 44 24 36	 mov	 BYTE PTR hbuf$[rsp+2], al
  003a0	44 88 74 24 37	 mov	 BYTE PTR hbuf$[rsp+3], r14b
  003a5	e8 00 00 00 00	 call	 crc32
  003aa	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN53@inflate:

; 731  :             INITBITS();

  003ae	45 8b f7	 mov	 r14d, r15d

; 732  :             state->mode = OS;

  003b1	41 c7 45 08 37
	3f 00 00	 mov	 DWORD PTR [r13+8], 16183 ; 00003f37H
  003b9	41 8b df	 mov	 ebx, r15d

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  003bc	eb 05		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  003be	83 fb 10	 cmp	 ebx, 16
  003c1	73 20		 jae	 SHORT $LN58@inflate
$LL61@inflate:
  003c3	85 f6		 test	 esi, esi
  003c5	0f 84 3c 05 00
	00		 je	 $LN938@inflate
  003cb	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  003cf	8b cb		 mov	 ecx, ebx
  003d1	d3 e0		 shl	 eax, cl
  003d3	ff ce		 dec	 esi
  003d5	44 03 f0	 add	 r14d, eax
  003d8	48 ff c5	 inc	 rbp
  003db	83 c3 08	 add	 ebx, 8
  003de	83 fb 10	 cmp	 ebx, 16
  003e1	72 e0		 jb	 SHORT $LL61@inflate
$LN58@inflate:

; 735  :             if (state->head != Z_NULL) {

  003e3	49 8b 55 28	 mov	 rdx, QWORD PTR [r13+40]
  003e7	41 8b ce	 mov	 ecx, r14d
  003ea	c1 e9 08	 shr	 ecx, 8
  003ed	48 85 d2	 test	 rdx, rdx
  003f0	74 0e		 je	 SHORT $LN723@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  003f2	41 0f b6 c6	 movzx	 eax, r14b
  003f6	89 42 08	 mov	 DWORD PTR [rdx+8], eax

; 737  :                 state->head->os = (int)(hold >> 8);

  003f9	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  003fd	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN723@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00400	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00408	74 28		 je	 SHORT $LN67@inflate
  0040a	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  0040f	74 21		 je	 SHORT $LN67@inflate

; 740  :                 CRC2(state->check, hold);

  00411	88 4c 24 35	 mov	 BYTE PTR hbuf$[rsp+1], cl
  00415	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0041a	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0041e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00424	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  00429	e8 00 00 00 00	 call	 crc32
  0042e	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN67@inflate:

; 741  :             INITBITS();

  00432	45 8b f7	 mov	 r14d, r15d

; 742  :             state->mode = EXLEN;

  00435	41 c7 45 08 38
	3f 00 00	 mov	 DWORD PTR [r13+8], 16184 ; 00003f38H
  0043d	41 8b df	 mov	 ebx, r15d
$LN361@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  00440	41 f7 45 18 00
	04 00 00	 test	 DWORD PTR [r13+24], 1024 ; 00000400H
  00448	74 76		 je	 SHORT $LN362@inflate

; 745  :                 NEEDBITS(16);

  0044a	83 fb 10	 cmp	 ebx, 16
  0044d	73 21		 jae	 SHORT $LN72@inflate
  0044f	90		 npad	 1
$LL75@inflate:
  00450	85 f6		 test	 esi, esi
  00452	0f 84 af 04 00
	00		 je	 $LN938@inflate
  00458	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  0045c	8b cb		 mov	 ecx, ebx
  0045e	d3 e0		 shl	 eax, cl
  00460	ff ce		 dec	 esi
  00462	44 03 f0	 add	 r14d, eax
  00465	48 ff c5	 inc	 rbp
  00468	83 c3 08	 add	 ebx, 8
  0046b	83 fb 10	 cmp	 ebx, 16
  0046e	72 e0		 jb	 SHORT $LL75@inflate
$LN72@inflate:

; 746  :                 state->length = (unsigned)(hold);
; 747  :                 if (state->head != Z_NULL)

  00470	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00474	45 89 75 50	 mov	 DWORD PTR [r13+80], r14d
  00478	48 85 c0	 test	 rax, rax
  0047b	74 04		 je	 SHORT $LN365@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  0047d	44 89 70 18	 mov	 DWORD PTR [rax+24], r14d
$LN365@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00481	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00489	74 2d		 je	 SHORT $LN81@inflate
  0048b	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00490	74 26		 je	 SHORT $LN81@inflate

; 750  :                     CRC2(state->check, hold);

  00492	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00496	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0049b	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  004a0	41 b8 02 00 00
	00		 mov	 r8d, 2
  004a6	41 c1 ee 08	 shr	 r14d, 8
  004aa	44 88 74 24 35	 mov	 BYTE PTR hbuf$[rsp+1], r14b
  004af	e8 00 00 00 00	 call	 crc32
  004b4	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN81@inflate:

; 751  :                 INITBITS();

  004b8	45 8b f7	 mov	 r14d, r15d
  004bb	41 8b df	 mov	 ebx, r15d

; 752  :             }

  004be	eb 0d		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 753  :             else if (state->head != Z_NULL)

  004c0	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  004c4	48 85 c0	 test	 rax, rax
  004c7	74 04		 je	 SHORT $LN367@inflate

; 754  :                 state->head->extra = Z_NULL;

  004c9	4c 89 78 10	 mov	 QWORD PTR [rax+16], r15
$LN367@inflate:

; 755  :             state->mode = EXTRA;

  004cd	41 c7 45 08 39
	3f 00 00	 mov	 DWORD PTR [r13+8], 16185 ; 00003f39H
$LN368@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  004d5	41 f7 45 18 00
	04 00 00	 test	 DWORD PTR [r13+24], 1024 ; 00000400H
  004dd	0f 84 95 00 00
	00		 je	 $LN724@inflate

; 758  :                 copy = state->length;

  004e3	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]

; 759  :                 if (copy > have) copy = have;
; 760  :                 if (copy) {

  004e7	8b fe		 mov	 edi, esi
  004e9	3b c6		 cmp	 eax, esi
  004eb	0f 46 f8	 cmovbe	 edi, eax
  004ee	85 ff		 test	 edi, edi
  004f0	74 7e		 je	 SHORT $LN725@inflate

; 761  :                     if (state->head != Z_NULL &&

  004f2	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  004f6	44 8b f8	 mov	 r15d, eax
  004f9	48 85 c9	 test	 rcx, rcx
  004fc	74 3b		 je	 SHORT $LN372@inflate
  004fe	4c 8b 51 10	 mov	 r10, QWORD PTR [rcx+16]
  00502	4d 85 d2	 test	 r10, r10
  00505	74 32		 je	 SHORT $LN372@inflate

; 762  :                         state->head->extra != Z_NULL) {
; 763  :                         len = state->head->extra_len - state->length;
; 764  :                         zmemcpy(state->head->extra + len, next,

  00507	44 8b 41 1c	 mov	 r8d, DWORD PTR [rcx+28]
  0050b	41 8b d0	 mov	 edx, r8d
  0050e	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  00512	44 2b c8	 sub	 r9d, eax
  00515	8b c7		 mov	 eax, edi
  00517	41 2b d1	 sub	 edx, r9d
  0051a	41 8d 0c 39	 lea	 ecx, DWORD PTR [r9+rdi]
  0051e	41 3b c8	 cmp	 ecx, r8d
  00521	41 8b c9	 mov	 ecx, r9d
  00524	0f 47 c2	 cmova	 eax, edx
  00527	49 03 ca	 add	 rcx, r10
  0052a	44 8b c0	 mov	 r8d, eax
  0052d	48 8b d5	 mov	 rdx, rbp
  00530	e8 00 00 00 00	 call	 memcpy
  00535	45 8b 7d 50	 mov	 r15d, DWORD PTR [r13+80]
$LN372@inflate:

; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);
; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  00539	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00541	74 1a		 je	 SHORT $LN373@inflate
  00543	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00548	74 13		 je	 SHORT $LN373@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  0054a	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0054e	44 8b c7	 mov	 r8d, edi
  00551	48 8b d5	 mov	 rdx, rbp
  00554	e8 00 00 00 00	 call	 crc32
  00559	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN373@inflate:

; 770  :                     have -= copy;
; 771  :                     next += copy;

  0055d	8b c7		 mov	 eax, edi
  0055f	2b f7		 sub	 esi, edi
  00561	48 03 e8	 add	 rbp, rax

; 772  :                     state->length -= copy;

  00564	41 8b c7	 mov	 eax, r15d
  00567	2b c7		 sub	 eax, edi
  00569	41 89 45 50	 mov	 DWORD PTR [r13+80], eax
  0056d	45 33 ff	 xor	 r15d, r15d
$LN725@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  00570	85 c0		 test	 eax, eax
  00572	0f 85 8f 03 00
	00		 jne	 $LN938@inflate
$LN724@inflate:

; 775  :             }
; 776  :             state->length = 0;

  00578	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d

; 777  :             state->mode = NAME;

  0057c	41 c7 45 08 3a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16186 ; 00003f3aH
$LN375@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  00584	41 f7 45 18 00
	08 00 00	 test	 DWORD PTR [r13+24], 2048 ; 00000800H
  0058c	0f 84 7c 00 00
	00		 je	 $LN376@inflate

; 780  :                 if (have == 0) goto inf_leave;

  00592	85 f6		 test	 esi, esi
  00594	0f 84 6d 03 00
	00		 je	 $LN938@inflate

; 781  :                 copy = 0;

  0059a	41 8b ff	 mov	 edi, r15d
  0059d	0f 1f 00	 npad	 3
$LL88@inflate:

; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  005a0	8b c7		 mov	 eax, edi
  005a2	ff c7		 inc	 edi
  005a4	44 0f b6 3c 28	 movzx	 r15d, BYTE PTR [rax+rbp]

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&

  005a9	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  005ad	48 85 c0	 test	 rax, rax
  005b0	74 1a		 je	 SHORT $LN86@inflate
  005b2	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  005b6	48 85 d2	 test	 rdx, rdx
  005b9	74 11		 je	 SHORT $LN86@inflate
  005bb	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  005bf	3b 48 28	 cmp	 ecx, DWORD PTR [rax+40]
  005c2	73 08		 jae	 SHORT $LN86@inflate

; 786  :                             state->length < state->head->name_max)
; 787  :                         state->head->name[state->length++] = (Bytef)len;

  005c4	44 88 3c 11	 mov	 BYTE PTR [rcx+rdx], r15b
  005c8	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN86@inflate:

; 788  :                 } while (len && copy < have);

  005cc	45 84 ff	 test	 r15b, r15b
  005cf	74 04		 je	 SHORT $LN380@inflate
  005d1	3b fe		 cmp	 edi, esi
  005d3	72 cb		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  005d5	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  005dd	74 1a		 je	 SHORT $LN381@inflate
  005df	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  005e4	74 13		 je	 SHORT $LN381@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  005e6	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  005ea	44 8b c7	 mov	 r8d, edi
  005ed	48 8b d5	 mov	 rdx, rbp
  005f0	e8 00 00 00 00	 call	 crc32
  005f5	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN381@inflate:

; 791  :                 have -= copy;
; 792  :                 next += copy;

  005f9	8b c7		 mov	 eax, edi
  005fb	2b f7		 sub	 esi, edi
  005fd	48 03 e8	 add	 rbp, rax

; 793  :                 if (len) goto inf_leave;

  00600	45 84 ff	 test	 r15b, r15b
  00603	0f 85 fe 02 00
	00		 jne	 $LN938@inflate

; 794  :             }

  00609	45 33 ff	 xor	 r15d, r15d
  0060c	eb 0d		 jmp	 SHORT $LN383@inflate
$LN376@inflate:

; 795  :             else if (state->head != Z_NULL)

  0060e	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00612	48 85 c0	 test	 rax, rax
  00615	74 04		 je	 SHORT $LN383@inflate

; 796  :                 state->head->name = Z_NULL;

  00617	4c 89 78 20	 mov	 QWORD PTR [rax+32], r15
$LN383@inflate:

; 797  :             state->length = 0;

  0061b	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d

; 798  :             state->mode = COMMENT;

  0061f	41 c7 45 08 3b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16187 ; 00003f3bH
$LN384@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  00627	41 f7 45 18 00
	10 00 00	 test	 DWORD PTR [r13+24], 4096 ; 00001000H
  0062f	74 7d		 je	 SHORT $LN385@inflate

; 801  :                 if (have == 0) goto inf_leave;

  00631	85 f6		 test	 esi, esi
  00633	0f 84 ce 02 00
	00		 je	 $LN938@inflate

; 802  :                 copy = 0;

  00639	41 8b ff	 mov	 edi, r15d
  0063c	0f 1f 40 00	 npad	 4
$LL91@inflate:

; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  00640	8b c7		 mov	 eax, edi
  00642	ff c7		 inc	 edi
  00644	44 0f b6 3c 28	 movzx	 r15d, BYTE PTR [rax+rbp]

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&

  00649	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0064d	48 85 c0	 test	 rax, rax
  00650	74 1a		 je	 SHORT $LN89@inflate
  00652	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  00656	48 85 d2	 test	 rdx, rdx
  00659	74 11		 je	 SHORT $LN89@inflate
  0065b	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  0065f	3b 48 38	 cmp	 ecx, DWORD PTR [rax+56]
  00662	73 08		 jae	 SHORT $LN89@inflate

; 807  :                             state->length < state->head->comm_max)
; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  00664	44 88 3c 11	 mov	 BYTE PTR [rcx+rdx], r15b
  00668	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN89@inflate:

; 809  :                 } while (len && copy < have);

  0066c	45 84 ff	 test	 r15b, r15b
  0066f	74 04		 je	 SHORT $LN389@inflate
  00671	3b fe		 cmp	 edi, esi
  00673	72 cb		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00675	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  0067d	74 1a		 je	 SHORT $LN390@inflate
  0067f	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00684	74 13		 je	 SHORT $LN390@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  00686	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0068a	44 8b c7	 mov	 r8d, edi
  0068d	48 8b d5	 mov	 rdx, rbp
  00690	e8 00 00 00 00	 call	 crc32
  00695	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN390@inflate:

; 812  :                 have -= copy;
; 813  :                 next += copy;

  00699	8b c7		 mov	 eax, edi
  0069b	2b f7		 sub	 esi, edi
  0069d	48 03 e8	 add	 rbp, rax

; 814  :                 if (len) goto inf_leave;

  006a0	45 84 ff	 test	 r15b, r15b
  006a3	0f 85 5e 02 00
	00		 jne	 $LN938@inflate

; 815  :             }

  006a9	45 33 ff	 xor	 r15d, r15d
  006ac	eb 0d		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 816  :             else if (state->head != Z_NULL)

  006ae	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  006b2	48 85 c0	 test	 rax, rax
  006b5	74 04		 je	 SHORT $LN392@inflate

; 817  :                 state->head->comment = Z_NULL;

  006b7	4c 89 78 30	 mov	 QWORD PTR [rax+48], r15
$LN392@inflate:
  006bb	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  006c0	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]

; 818  :             state->mode = HCRC;

  006c5	41 c7 45 08 3c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16188 ; 00003f3cH
$LN393@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  006cd	41 8b 55 18	 mov	 edx, DWORD PTR [r13+24]
  006d1	0f ba e2 09	 bt	 edx, 9
  006d5	73 56		 jae	 SHORT $LN101@inflate

; 821  :                 NEEDBITS(16);

  006d7	83 fb 10	 cmp	 ebx, 16
  006da	73 24		 jae	 SHORT $LN92@inflate
  006dc	0f 1f 40 00	 npad	 4
$LL95@inflate:
  006e0	85 f6		 test	 esi, esi
  006e2	0f 84 1f 02 00
	00		 je	 $LN938@inflate
  006e8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  006ec	8b cb		 mov	 ecx, ebx
  006ee	d3 e0		 shl	 eax, cl
  006f0	ff ce		 dec	 esi
  006f2	44 03 f0	 add	 r14d, eax
  006f5	48 ff c5	 inc	 rbp
  006f8	83 c3 08	 add	 ebx, 8
  006fb	83 fb 10	 cmp	 ebx, 16
  006fe	72 e0		 jb	 SHORT $LL95@inflate
$LN92@inflate:

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  00700	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00705	74 20		 je	 SHORT $LN102@inflate
  00707	41 0f b7 45 20	 movzx	 eax, WORD PTR [r13+32]
  0070c	44 3b f0	 cmp	 r14d, eax
  0070f	74 16		 je	 SHORT $LN102@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  00711	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
  00718	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 824  :                     state->mode = BAD;

  0071d	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 825  :                     break;

  00725	eb 4a		 jmp	 SHORT $LN8@inflate
$LN102@inflate:

; 826  :                 }
; 827  :                 INITBITS();

  00727	45 8b f7	 mov	 r14d, r15d
  0072a	41 8b df	 mov	 ebx, r15d
$LN101@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  0072d	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00731	48 85 c0	 test	 rax, rax
  00734	74 14		 je	 SHORT $LN397@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00736	c1 fa 09	 sar	 edx, 9
  00739	83 e2 01	 and	 edx, 1
  0073c	89 50 3c	 mov	 DWORD PTR [rax+60], edx

; 831  :                 state->head->done = 1;

  0073f	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00743	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN397@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  0074a	45 33 c0	 xor	 r8d, r8d
  0074d	33 d2		 xor	 edx, edx
  0074f	33 c9		 xor	 ecx, ecx
  00751	e8 00 00 00 00	 call	 crc32
  00756	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  0075a	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN978@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  0075f	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN975@inflate:
  00767	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
$LN905@inflate:
  0076c	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
$LN8@inflate:
  00771	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  00775	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  0077a	83 f8 1f	 cmp	 eax, 31
  0077d	0f 87 e3 0f 00
	00		 ja	 $LN333@inflate
  00783	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]
  0078b	45 33 ff	 xor	 r15d, r15d
  0078e	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  00795	e9 0c f9 ff ff	 jmp	 $LN976@inflate
$LN105@inflate:

; 834  :             state->mode = TYPE;
; 835  :             break;
; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  0079a	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0079d	73 21		 jae	 SHORT $LN103@inflate
  0079f	90		 npad	 1
$LL106@inflate:
  007a0	85 f6		 test	 esi, esi
  007a2	0f 84 5f 01 00
	00		 je	 $LN938@inflate
  007a8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  007ac	8b cb		 mov	 ecx, ebx
  007ae	d3 e0		 shl	 eax, cl
  007b0	ff ce		 dec	 esi
  007b2	44 03 f0	 add	 r14d, eax
  007b5	48 ff c5	 inc	 rbp
  007b8	83 c3 08	 add	 ebx, 8
  007bb	83 fb 20	 cmp	 ebx, 32			; 00000020H
  007be	72 e0		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  007c0	41 8b ce	 mov	 ecx, r14d
  007c3	41 8b c6	 mov	 eax, r14d
  007c6	c1 e0 10	 shl	 eax, 16
  007c9	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007cf	03 c8		 add	 ecx, eax

; 840  :             INITBITS();

  007d1	41 8b df	 mov	 ebx, r15d
  007d4	41 8b c6	 mov	 eax, r14d
  007d7	c1 e1 08	 shl	 ecx, 8
  007da	c1 e8 08	 shr	 eax, 8
  007dd	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  007e2	41 c1 ee 18	 shr	 r14d, 24
  007e6	03 c1		 add	 eax, ecx
  007e8	41 03 c6	 add	 eax, r14d
  007eb	45 8b f7	 mov	 r14d, r15d
  007ee	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  007f2	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax

; 841  :             state->mode = DICT;

  007f7	41 c7 45 08 3e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16190 ; 00003f3eH
$LN400@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  007ff	41 83 7d 14 00	 cmp	 DWORD PTR [r13+20], 0
  00804	0f 84 1c 0e 00
	00		 je	 $LN587@inflate

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0080a	45 33 c0	 xor	 r8d, r8d
  0080d	33 d2		 xor	 edx, edx
  0080f	33 c9		 xor	 ecx, ecx
  00811	e8 00 00 00 00	 call	 adler32
  00816	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  0081b	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
  00820	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  00827	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  0082b	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax

; 848  :             state->mode = TYPE;

  00830	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN402@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00838	8d 42 fb	 lea	 eax, DWORD PTR [rdx-5]
  0083b	83 f8 01	 cmp	 eax, 1
  0083e	0f 86 c3 00 00
	00		 jbe	 $LN938@inflate
$LN403@inflate:

; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  00844	41 83 7d 0c 00	 cmp	 DWORD PTR [r13+12], 0
  00849	74 17		 je	 SHORT $LN122@inflate

; 853  :                 BYTEBITS();

  0084b	8b cb		 mov	 ecx, ebx

; 854  :                 state->mode = CHECK;

  0084d	41 c7 45 08 4e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16206 ; 00003f4eH
  00855	83 e1 07	 and	 ecx, 7
  00858	41 d3 ee	 shr	 r14d, cl
  0085b	2b d9		 sub	 ebx, ecx

; 855  :                 break;

  0085d	e9 0f ff ff ff	 jmp	 $LN8@inflate
$LN122@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  00862	83 fb 03	 cmp	 ebx, 3
  00865	73 20		 jae	 SHORT $LN120@inflate
$LL123@inflate:
  00867	85 f6		 test	 esi, esi
  00869	0f 84 98 00 00
	00		 je	 $LN938@inflate
  0086f	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00873	8b cb		 mov	 ecx, ebx
  00875	d3 e0		 shl	 eax, cl
  00877	ff ce		 dec	 esi
  00879	44 03 f0	 add	 r14d, eax
  0087c	48 ff c5	 inc	 rbp
  0087f	83 c3 08	 add	 ebx, 8
  00882	83 fb 03	 cmp	 ebx, 3
  00885	72 e0		 jb	 SHORT $LL123@inflate
$LN120@inflate:

; 858  :             state->last = BITS(1);

  00887	41 8b c6	 mov	 eax, r14d

; 859  :             DROPBITS(1);

  0088a	41 d1 ee	 shr	 r14d, 1
  0088d	83 e0 01	 and	 eax, 1
  00890	41 89 45 0c	 mov	 DWORD PTR [r13+12], eax

; 860  :             switch (BITS(2)) {

  00894	41 8b c6	 mov	 eax, r14d
  00897	83 e0 03	 and	 eax, 3
  0089a	0f 84 01 01 00
	00		 je	 $LN408@inflate
  008a0	83 e8 01	 sub	 eax, 1
  008a3	74 42		 je	 SHORT $LN409@inflate
  008a5	83 e8 01	 sub	 eax, 1
  008a8	74 29		 je	 SHORT $LN411@inflate
  008aa	83 f8 01	 cmp	 eax, 1
  008ad	0f 85 f6 00 00
	00		 jne	 $LN138@inflate

; 873  :                     goto inf_leave;
; 874  :                 }
; 875  :                 break;
; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;
; 880  :                 break;
; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  008b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 883  :                 state->mode = BAD;
; 884  :             }
; 885  :             DROPBITS(2);

  008ba	41 c1 ee 02	 shr	 r14d, 2
  008be	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  008c3	83 c3 fd	 add	 ebx, -3			; fffffffdH
  008c6	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 886  :             break;

  008ce	e9 9e fe ff ff	 jmp	 $LN8@inflate
$LN411@inflate:

; 883  :                 state->mode = BAD;
; 884  :             }
; 885  :             DROPBITS(2);

  008d3	41 c1 ee 02	 shr	 r14d, 2
  008d7	83 c3 fd	 add	 ebx, -3			; fffffffdH
  008da	41 c7 45 08 44
	3f 00 00	 mov	 DWORD PTR [r13+8], 16196 ; 00003f44H

; 886  :             break;

  008e2	e9 8a fe ff ff	 jmp	 $LN8@inflate
$LN409@inflate:

; 865  :                 break;
; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  008e7	49 8b cd	 mov	 rcx, r13
  008ea	e8 00 00 00 00	 call	 fixedtables

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */

  008ef	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H

; 871  :                 if (flush == Z_TREES) {

  008f7	83 fa 06	 cmp	 edx, 6
  008fa	0f 85 a9 00 00
	00		 jne	 $LN138@inflate

; 872  :                     DROPBITS(2);

  00900	41 c1 ee 02	 shr	 r14d, 2
  00904	83 c3 fd	 add	 ebx, -3			; fffffffdH
$LN938@inflate:

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;
; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  00907	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]
$LN942@inflate:
  0090e	44 8b bc 24 a8
	00 00 00	 mov	 r15d, DWORD PTR ret$1$[rsp]
$LN977@inflate:
  00916	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR flush$[rsp]
$inf_leave$981:
  0091d	48 8b 44 24 40	 mov	 rax, QWORD PTR put$1$[rsp]
  00922	49 89 44 24 10	 mov	 QWORD PTR [r12+16], rax
  00927	8b 44 24 30	 mov	 eax, DWORD PTR left$1$[rsp]
  0092b	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
  00930	49 89 2c 24	 mov	 QWORD PTR [r12], rbp
  00934	41 89 74 24 08	 mov	 DWORD PTR [r12+8], esi

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  00939	41 83 7d 34 00	 cmp	 DWORD PTR [r13+52], 0
  0093e	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  00942	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  00946	75 2a		 jne	 SHORT $LN503@inflate
  00948	41 3b 7c 24 18	 cmp	 edi, DWORD PTR [r12+24]
  0094d	0f 84 41 0d 00
	00		 je	 $LN504@inflate
  00953	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  00957	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  0095c	0f 8d 32 0d 00
	00		 jge	 $LN504@inflate
  00962	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  00967	7c 09		 jl	 SHORT $LN503@inflate
  00969	83 f9 04	 cmp	 ecx, 4
  0096c	0f 84 22 0d 00
	00		 je	 $LN504@inflate
$LN503@inflate:

; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  00972	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  00977	44 8b c7	 mov	 r8d, edi
  0097a	45 2b 44 24 18	 sub	 r8d, DWORD PTR [r12+24]
  0097f	49 8b cc	 mov	 rcx, r12
  00982	e8 00 00 00 00	 call	 updatewindow
  00987	85 c0		 test	 eax, eax
  00989	0f 84 05 0d 00
	00		 je	 $LN504@inflate

; 1258 :             state->mode = MEM;

  0098f	41 c7 45 08 52
	3f 00 00	 mov	 DWORD PTR [r13+8], 16210 ; 00003f52H
$LN498@inflate:

; 1275 : }

  00997	b8 fc ff ff ff	 mov	 eax, -4
  0099c	e9 ca 0d 00 00	 jmp	 $LN1@inflate
$LN408@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;

  009a1	41 c7 45 08 41
	3f 00 00	 mov	 DWORD PTR [r13+8], 16193 ; 00003f41H
$LN138@inflate:

; 883  :                 state->mode = BAD;
; 884  :             }
; 885  :             DROPBITS(2);

  009a9	41 c1 ee 02	 shr	 r14d, 2
  009ad	83 c3 fd	 add	 ebx, -3			; fffffffdH

; 886  :             break;

  009b0	e9 bc fd ff ff	 jmp	 $LN8@inflate
$LN141@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  009b5	8b cb		 mov	 ecx, ebx
  009b7	83 e1 07	 and	 ecx, 7
  009ba	41 d3 ee	 shr	 r14d, cl
  009bd	2b d9		 sub	 ebx, ecx

; 889  :             NEEDBITS(32);

  009bf	83 fb 20	 cmp	 ebx, 32			; 00000020H
  009c2	73 20		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  009c4	85 f6		 test	 esi, esi
  009c6	0f 84 3b ff ff
	ff		 je	 $LN938@inflate
  009cc	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  009d0	8b cb		 mov	 ecx, ebx
  009d2	d3 e0		 shl	 eax, cl
  009d4	ff ce		 dec	 esi
  009d6	44 03 f0	 add	 r14d, eax
  009d9	48 ff c5	 inc	 rbp
  009dc	83 c3 08	 add	 ebx, 8
  009df	83 fb 20	 cmp	 ebx, 32			; 00000020H
  009e2	72 e0		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  009e4	41 8b c6	 mov	 eax, r14d
  009e7	41 0f b7 ce	 movzx	 ecx, r14w
  009eb	f7 d0		 not	 eax
  009ed	c1 e8 10	 shr	 eax, 16
  009f0	3b c8		 cmp	 ecx, eax
  009f2	74 19		 je	 SHORT $LN415@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  009f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  009fb	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 892  :                 state->mode = BAD;

  00a00	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 893  :                 break;

  00a08	e9 64 fd ff ff	 jmp	 $LN8@inflate
$LN415@inflate:

; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;

  00a0d	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  00a11	45 8b f7	 mov	 r14d, r15d

; 899  :             state->mode = COPY_;

  00a14	41 c7 45 08 42
	3f 00 00	 mov	 DWORD PTR [r13+8], 16194 ; 00003f42H
  00a1c	41 8b df	 mov	 ebx, r15d

; 900  :             if (flush == Z_TREES) goto inf_leave;

  00a1f	83 fa 06	 cmp	 edx, 6
  00a22	0f 84 df fe ff
	ff		 je	 $LN938@inflate
$LN416@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  00a28	41 c7 45 08 43
	3f 00 00	 mov	 DWORD PTR [r13+8], 16195 ; 00003f43H
$LN418@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  00a30	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]

; 905  :             if (copy) {

  00a34	85 c9		 test	 ecx, ecx
  00a36	74 54		 je	 SHORT $LN419@inflate

; 906  :                 if (copy > have) copy = have;
; 907  :                 if (copy > left) copy = left;

  00a38	3b ce		 cmp	 ecx, esi
  00a3a	8b c6		 mov	 eax, esi

; 908  :                 if (copy == 0) goto inf_leave;

  00a3c	45 8b fb	 mov	 r15d, r11d
  00a3f	0f 46 c1	 cmovbe	 eax, ecx
  00a42	41 3b c3	 cmp	 eax, r11d
  00a45	44 0f 46 f8	 cmovbe	 r15d, eax
  00a49	45 85 ff	 test	 r15d, r15d
  00a4c	0f 84 b5 fe ff
	ff		 je	 $LN938@inflate

; 909  :                 zmemcpy(put, next, copy);

  00a52	45 8b c7	 mov	 r8d, r15d
  00a55	48 8b d5	 mov	 rdx, rbp
  00a58	49 8b ca	 mov	 rcx, r10
  00a5b	41 8b ff	 mov	 edi, r15d
  00a5e	e8 00 00 00 00	 call	 memcpy

; 910  :                 have -= copy;
; 911  :                 next += copy;
; 912  :                 left -= copy;

  00a63	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
  00a68	41 2b f7	 sub	 esi, r15d

; 913  :                 put += copy;

  00a6b	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  00a70	45 2b df	 sub	 r11d, r15d
  00a73	4c 03 d7	 add	 r10, rdi
  00a76	44 89 5c 24 30	 mov	 DWORD PTR left$1$[rsp], r11d
  00a7b	48 03 ef	 add	 rbp, rdi
  00a7e	4c 89 54 24 40	 mov	 QWORD PTR put$1$[rsp], r10

; 914  :                 state->length -= copy;

  00a83	45 29 7d 50	 sub	 DWORD PTR [r13+80], r15d

; 915  :                 break;

  00a87	e9 e5 fc ff ff	 jmp	 $LN8@inflate
$LN419@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;

  00a8c	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH

; 919  :             break;

  00a94	e9 d8 fc ff ff	 jmp	 $LN8@inflate
$LN155@inflate:

; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  00a99	83 fb 0e	 cmp	 ebx, 14
  00a9c	73 22		 jae	 SHORT $LN153@inflate
  00a9e	66 90		 npad	 2
$LL156@inflate:
  00aa0	85 f6		 test	 esi, esi
  00aa2	0f 84 5f fe ff
	ff		 je	 $LN938@inflate
  00aa8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00aac	8b cb		 mov	 ecx, ebx
  00aae	d3 e0		 shl	 eax, cl
  00ab0	ff ce		 dec	 esi
  00ab2	44 03 f0	 add	 r14d, eax
  00ab5	48 ff c5	 inc	 rbp
  00ab8	83 c3 08	 add	 ebx, 8
  00abb	83 fb 0e	 cmp	 ebx, 14
  00abe	72 e0		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 922  :             state->nlen = BITS(5) + 257;

  00ac0	41 8b ce	 mov	 ecx, r14d

; 923  :             DROPBITS(5);
; 924  :             state->ndist = BITS(5) + 1;
; 925  :             DROPBITS(5);
; 926  :             state->ncode = BITS(4) + 4;
; 927  :             DROPBITS(4);

  00ac3	83 c3 f2	 add	 ebx, -14		; fffffff2H
  00ac6	41 c1 ee 05	 shr	 r14d, 5
  00aca	83 e1 1f	 and	 ecx, 31
  00acd	41 8b d6	 mov	 edx, r14d
  00ad0	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00ad6	41 c1 ee 05	 shr	 r14d, 5
  00ada	83 e2 1f	 and	 edx, 31
  00add	41 8b c6	 mov	 eax, r14d
  00ae0	41 89 4d 7c	 mov	 DWORD PTR [r13+124], ecx
  00ae4	83 e0 0f	 and	 eax, 15
  00ae7	41 c1 ee 04	 shr	 r14d, 4
  00aeb	83 c0 04	 add	 eax, 4
  00aee	ff c2		 inc	 edx
  00af0	41 89 95 80 00
	00 00		 mov	 DWORD PTR [r13+128], edx
  00af7	41 89 45 78	 mov	 DWORD PTR [r13+120], eax

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  00afb	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00b01	0f 87 1e 01 00
	00		 ja	 $LN426@inflate
  00b07	83 fa 1e	 cmp	 edx, 30
  00b0a	0f 87 15 01 00
	00		 ja	 $LN426@inflate

; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  00b10	45 89 bd 84 00
	00 00		 mov	 DWORD PTR [r13+132], r15d

; 937  :             state->mode = LENLENS;

  00b17	41 c7 45 08 45
	3f 00 00	 mov	 DWORD PTR [r13+8], 16197 ; 00003f45H
$LN533@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  00b1f	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b26	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00b2d	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  00b31	73 60		 jae	 SHORT $LN535@inflate
$LL170@inflate:

; 940  :                 NEEDBITS(3);

  00b33	83 fb 03	 cmp	 ebx, 3
  00b36	73 20		 jae	 SHORT $LN172@inflate
$LL175@inflate:
  00b38	85 f6		 test	 esi, esi
  00b3a	0f 84 c7 fd ff
	ff		 je	 $LN938@inflate
  00b40	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00b44	8b cb		 mov	 ecx, ebx
  00b46	d3 e0		 shl	 eax, cl
  00b48	ff ce		 dec	 esi
  00b4a	44 03 f0	 add	 r14d, eax
  00b4d	48 ff c5	 inc	 rbp
  00b50	83 c3 08	 add	 ebx, 8
  00b53	83 fb 03	 cmp	 ebx, 3
  00b56	72 e0		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00b58	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b5f	41 0f b7 ce	 movzx	 ecx, r14w
  00b63	66 83 e1 07	 and	 cx, 7

; 942  :                 DROPBITS(3);

  00b67	41 c1 ee 03	 shr	 r14d, 3
  00b6b	83 c3 fd	 add	 ebx, -3			; fffffffdH
  00b6e	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00b76	66 41 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], cx
  00b7f	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00b86	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b8d	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  00b91	72 a0		 jb	 SHORT $LL170@inflate
$LN535@inflate:

; 943  :             }
; 944  :             while (state->have < 19)

  00b93	83 f8 13	 cmp	 eax, 19
  00b96	73 26		 jae	 SHORT $LN184@inflate
$LL183@inflate:

; 945  :                 state->lens[order[state->have++]] = 0;

  00b98	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00ba0	66 45 89 bc 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r15w
  00ba9	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00bb0	ff c0		 inc	 eax
  00bb2	41 89 85 84 00
	00 00		 mov	 DWORD PTR [r13+132], eax
  00bb9	83 f8 13	 cmp	 eax, 19
  00bbc	72 da		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 946  :             state->next = state->codes;

  00bbe	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]

; 947  :             state->lencode = (const code FAR *)(state->next);
; 948  :             state->lenbits = 7;

  00bc5	c7 07 07 00 00
	00		 mov	 DWORD PTR [rdi], 7
  00bcb	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00bd2	49 89 45 60	 mov	 QWORD PTR [r13+96], rax

; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00bd6	33 c9		 xor	 ecx, ecx
  00bd8	49 89 01	 mov	 QWORD PTR [r9], rax
  00bdb	49 8d 85 10 03
	00 00		 lea	 rax, QWORD PTR [r13+784]
  00be2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00be7	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00bee	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00bf3	44 8d 41 13	 lea	 r8d, QWORD PTR [rcx+19]
  00bf7	e8 00 00 00 00	 call	 inflate_table

; 950  :                                 &(state->lenbits), state->work);
; 951  :             if (ret) {

  00bfc	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
  00c01	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax
  00c08	85 c0		 test	 eax, eax
  00c0a	74 32		 je	 SHORT $LN429@inflate

; 952  :                 strm->msg = (char *)"invalid code lengths set";

  00c0c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  00c13	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 953  :                 state->mode = BAD;

  00c18	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 954  :                 break;

  00c20	e9 47 fb ff ff	 jmp	 $LN905@inflate
$LN426@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  00c25	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00c2c	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 931  :                 state->mode = BAD;

  00c31	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 932  :                 break;

  00c39	e9 33 fb ff ff	 jmp	 $LN8@inflate
$LN429@inflate:

; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  00c3e	45 89 bd 84 00
	00 00		 mov	 DWORD PTR [r13+132], r15d

; 958  :             state->mode = CODELENS;

  00c45	41 c7 45 08 46
	3f 00 00	 mov	 DWORD PTR [r13+8], 16198 ; 00003f46H
$LN536@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00c4d	41 8b 85 80 00
	00 00		 mov	 eax, DWORD PTR [r13+128]
  00c54	41 03 45 7c	 add	 eax, DWORD PTR [r13+124]
  00c58	41 39 85 84 00
	00 00		 cmp	 DWORD PTR [r13+132], eax
  00c5f	0f 83 38 02 00
	00		 jae	 $LN186@inflate
  00c65	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL185@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  00c70	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00c72	41 b9 01 00 00
	00		 mov	 r9d, 1
  00c78	4d 8b 55 60	 mov	 r10, QWORD PTR [r13+96]
  00c7c	41 d3 e1	 shl	 r9d, cl
  00c7f	41 ff c9	 dec	 r9d
  00c82	41 8b c6	 mov	 eax, r14d
  00c85	41 8b c9	 mov	 ecx, r9d
  00c88	48 23 c8	 and	 rcx, rax
  00c8b	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  00c8f	44 8b c0	 mov	 r8d, eax
  00c92	41 c1 e8 08	 shr	 r8d, 8
  00c96	8b d0		 mov	 edx, eax
  00c98	41 0f b6 c8	 movzx	 ecx, r8b
  00c9c	c1 ea 10	 shr	 edx, 16
  00c9f	89 44 24 38	 mov	 DWORD PTR here$[rsp], eax

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  00ca3	3b cb		 cmp	 ecx, ebx
  00ca5	76 43		 jbe	 SHORT $LN563@inflate
$LL187@inflate:

; 964  :                     PULLBYTE();

  00ca7	85 f6		 test	 esi, esi
  00ca9	0f 84 58 fc ff
	ff		 je	 $LN938@inflate
  00caf	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00cb3	8b cb		 mov	 ecx, ebx
  00cb5	d3 e0		 shl	 eax, cl
  00cb7	ff ce		 dec	 esi
  00cb9	44 03 f0	 add	 r14d, eax
  00cbc	48 ff c5	 inc	 rbp
  00cbf	41 8b c1	 mov	 eax, r9d
  00cc2	83 c3 08	 add	 ebx, 8
  00cc5	41 8b ce	 mov	 ecx, r14d
  00cc8	48 23 c8	 and	 rcx, rax
  00ccb	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  00ccf	44 8b c0	 mov	 r8d, eax
  00cd2	41 c1 e8 08	 shr	 r8d, 8
  00cd6	8b c8		 mov	 ecx, eax
  00cd8	41 0f b6 d0	 movzx	 edx, r8b
  00cdc	c1 e9 10	 shr	 ecx, 16
  00cdf	89 44 24 38	 mov	 DWORD PTR here$[rsp], eax
  00ce3	3b d3		 cmp	 edx, ebx
  00ce5	77 c0		 ja	 SHORT $LL187@inflate

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  00ce7	0f b7 d1	 movzx	 edx, cx
$LN563@inflate:

; 965  :                 }
; 966  :                 if (here.val < 16) {

  00cea	66 83 fa 10	 cmp	 dx, 16
  00cee	73 36		 jae	 SHORT $LN433@inflate

; 967  :                     DROPBITS(here.bits);

  00cf0	41 8b c8	 mov	 ecx, r8d
  00cf3	41 d3 ee	 shr	 r14d, cl
  00cf6	8b c8		 mov	 ecx, eax
  00cf8	c1 e9 08	 shr	 ecx, 8
  00cfb	0f b6 c9	 movzx	 ecx, cl
  00cfe	2b d9		 sub	 ebx, ecx

; 968  :                     state->lens[state->have++] = here.val;

  00d00	c1 e8 10	 shr	 eax, 16
  00d03	41 8b 8d 84 00
	00 00		 mov	 ecx, DWORD PTR [r13+132]
  00d0a	66 41 89 84 4d
	90 00 00 00	 mov	 WORD PTR [r13+rcx*2+144], ax
  00d13	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00d1a	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]

; 969  :                 }

  00d21	e9 4d 01 00 00	 jmp	 $LN611@inflate
$LN433@inflate:

; 970  :                 else {
; 971  :                     if (here.val == 16) {

  00d26	75 6f		 jne	 SHORT $LN435@inflate

; 972  :                         NEEDBITS(here.bits + 2);

  00d28	c1 e8 08	 shr	 eax, 8
  00d2b	41 0f b6 d0	 movzx	 edx, r8b
  00d2f	83 c2 02	 add	 edx, 2
  00d32	44 0f b6 c8	 movzx	 r9d, al
  00d36	3b da		 cmp	 ebx, edx
  00d38	73 25		 jae	 SHORT $LN196@inflate
  00d3a	66 0f 1f 44 00
	00		 npad	 6
$LL199@inflate:
  00d40	85 f6		 test	 esi, esi
  00d42	0f 84 bf fb ff
	ff		 je	 $LN938@inflate
  00d48	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00d4c	8b cb		 mov	 ecx, ebx
  00d4e	d3 e0		 shl	 eax, cl
  00d50	ff ce		 dec	 esi
  00d52	44 03 f0	 add	 r14d, eax
  00d55	48 ff c5	 inc	 rbp
  00d58	83 c3 08	 add	 ebx, 8
  00d5b	3b da		 cmp	 ebx, edx
  00d5d	72 e1		 jb	 SHORT $LL199@inflate
$LN196@inflate:

; 973  :                         DROPBITS(here.bits);
; 974  :                         if (state->have == 0) {

  00d5f	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00d66	41 8b c9	 mov	 ecx, r9d
  00d69	41 d3 ee	 shr	 r14d, cl
  00d6c	41 2b d9	 sub	 ebx, r9d
  00d6f	85 c0		 test	 eax, eax
  00d71	0f 84 12 01 00
	00		 je	 $LN569@inflate

; 975  :                             strm->msg = (char *)"invalid bit length repeat";
; 976  :                             state->mode = BAD;
; 977  :                             break;
; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];
; 980  :                         copy = 3 + BITS(2);

  00d77	41 8b d6	 mov	 edx, r14d

; 981  :                         DROPBITS(2);

  00d7a	83 c3 fe	 add	 ebx, -2			; fffffffeH
  00d7d	83 e2 03	 and	 edx, 3
  00d80	41 c1 ee 02	 shr	 r14d, 2
  00d84	83 c2 03	 add	 edx, 3
  00d87	ff c8		 dec	 eax
  00d89	45 0f b7 8c 45
	90 00 00 00	 movzx	 r9d, WORD PTR [r13+rax*2+144]

; 982  :                     }

  00d92	e9 9f 00 00 00	 jmp	 $LN236@inflate
$LN435@inflate:

; 983  :                     else if (here.val == 17) {

  00d97	44 0f b6 4c 24
	39		 movzx	 r9d, BYTE PTR here$[rsp+1]
  00d9d	66 83 fa 11	 cmp	 dx, 17
  00da1	41 0f b6 d0	 movzx	 edx, r8b
  00da5	75 48		 jne	 SHORT $LN226@inflate

; 984  :                         NEEDBITS(here.bits + 3);

  00da7	83 c2 03	 add	 edx, 3
  00daa	3b da		 cmp	 ebx, edx
  00dac	73 21		 jae	 SHORT $LN210@inflate
  00dae	66 90		 npad	 2
$LL213@inflate:
  00db0	85 f6		 test	 esi, esi
  00db2	0f 84 4f fb ff
	ff		 je	 $LN938@inflate
  00db8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00dbc	8b cb		 mov	 ecx, ebx
  00dbe	d3 e0		 shl	 eax, cl
  00dc0	ff ce		 dec	 esi
  00dc2	44 03 f0	 add	 r14d, eax
  00dc5	48 ff c5	 inc	 rbp
  00dc8	83 c3 08	 add	 ebx, 8
  00dcb	3b da		 cmp	 ebx, edx
  00dcd	72 e1		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 985  :                         DROPBITS(here.bits);

  00dcf	41 8b c9	 mov	 ecx, r9d

; 986  :                         len = 0;
; 987  :                         copy = 3 + BITS(3);
; 988  :                         DROPBITS(3);

  00dd2	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00dd7	41 d3 ee	 shr	 r14d, cl
  00dda	41 8b d6	 mov	 edx, r14d
  00ddd	41 c1 ee 03	 shr	 r14d, 3
  00de1	83 e2 07	 and	 edx, 7
  00de4	83 c2 03	 add	 edx, 3
  00de7	41 2b c1	 sub	 eax, r9d
  00dea	45 8b cf	 mov	 r9d, r15d

; 989  :                     }

  00ded	eb 45		 jmp	 SHORT $LN972@inflate
$LN226@inflate:

; 990  :                     else {
; 991  :                         NEEDBITS(here.bits + 7);

  00def	83 c2 07	 add	 edx, 7
  00df2	3b da		 cmp	 ebx, edx
  00df4	73 1f		 jae	 SHORT $LN224@inflate
$LL227@inflate:
  00df6	85 f6		 test	 esi, esi
  00df8	0f 84 09 fb ff
	ff		 je	 $LN938@inflate
  00dfe	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00e02	8b cb		 mov	 ecx, ebx
  00e04	d3 e0		 shl	 eax, cl
  00e06	ff ce		 dec	 esi
  00e08	44 03 f0	 add	 r14d, eax
  00e0b	48 ff c5	 inc	 rbp
  00e0e	83 c3 08	 add	 ebx, 8
  00e11	3b da		 cmp	 ebx, edx
  00e13	72 e1		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 992  :                         DROPBITS(here.bits);

  00e15	41 8b c9	 mov	 ecx, r9d

; 993  :                         len = 0;
; 994  :                         copy = 11 + BITS(7);
; 995  :                         DROPBITS(7);

  00e18	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00e1d	41 d3 ee	 shr	 r14d, cl
  00e20	41 8b d6	 mov	 edx, r14d
  00e23	41 c1 ee 07	 shr	 r14d, 7
  00e27	83 e2 7f	 and	 edx, 127		; 0000007fH
  00e2a	83 c2 0b	 add	 edx, 11
  00e2d	41 2b c1	 sub	 eax, r9d
  00e30	45 0f b7 cf	 movzx	 r9d, r15w
$LN972@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  00e34	03 d8		 add	 ebx, eax
$LN236@inflate:
  00e36	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]
  00e3d	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00e41	41 03 85 80 00
	00 00		 add	 eax, DWORD PTR [r13+128]
  00e48	41 8d 0c 10	 lea	 ecx, DWORD PTR [r8+rdx]
  00e4c	3b c8		 cmp	 ecx, eax
  00e4e	77 39		 ja	 SHORT $LN569@inflate
$LL238@inflate:

; 998  :                         strm->msg = (char *)"invalid bit length repeat";
; 999  :                         state->mode = BAD;
; 1000 :                         break;
; 1001 :                     }
; 1002 :                     while (copy--)
; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  00e50	41 8b c0	 mov	 eax, r8d
  00e53	66 45 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r9w
  00e5c	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]
  00e63	45 8d 40 01	 lea	 r8d, DWORD PTR [r8+1]
  00e67	45 89 85 84 00
	00 00		 mov	 DWORD PTR [r13+132], r8d
  00e6e	83 c2 ff	 add	 edx, -1			; ffffffffH
  00e71	75 dd		 jne	 SHORT $LL238@inflate
$LN611@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00e73	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00e77	41 03 85 80 00
	00 00		 add	 eax, DWORD PTR [r13+128]
  00e7e	44 3b c0	 cmp	 r8d, eax
  00e81	0f 82 e9 fd ff
	ff		 jb	 $LL185@inflate
  00e87	eb 14		 jmp	 SHORT $LN186@inflate
$LN569@inflate:

; 1004 :                 }
; 1005 :             }
; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  00e89	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00e90	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  00e95	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
$LN186@inflate:
  00e9d	41 81 7d 08 51
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00ea5	0f 84 c1 f8 ff
	ff		 je	 $LN905@inflate

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  00eab	66 41 83 bd 90
	02 00 00 00	 cmp	 WORD PTR [r13+656], 0
  00eb4	75 19		 jne	 SHORT $LN445@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00eb6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  00ebd	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1013 :                 state->mode = BAD;

  00ec2	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1014 :                 break;

  00eca	e9 9d f8 ff ff	 jmp	 $LN905@inflate
$LN445@inflate:

; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;
; 1021 :             state->lencode = (const code FAR *)(state->next);
; 1022 :             state->lenbits = 9;
; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00ecf	45 8b 45 7c	 mov	 r8d, DWORD PTR [r13+124]
  00ed3	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]
  00eda	49 89 85 88 00
	00 00		 mov	 QWORD PTR [r13+136], rax
  00ee1	4d 8d bd 10 03
	00 00		 lea	 r15, QWORD PTR [r13+784]
  00ee8	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  00eec	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00ef3	49 8d 45 70	 lea	 rax, QWORD PTR [r13+112]
  00ef7	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00efc	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00f03	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
  00f09	b9 01 00 00 00	 mov	 ecx, 1
  00f0e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f13	e8 00 00 00 00	 call	 inflate_table
  00f18	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax

; 1024 :                                 &(state->lenbits), state->work);
; 1025 :             if (ret) {

  00f1f	85 c0		 test	 eax, eax
  00f21	74 19		 je	 SHORT $LN446@inflate

; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";

  00f23	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00f2a	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  00f2f	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00f37	e9 2b f8 ff ff	 jmp	 $LN975@inflate
$LN446@inflate:

; 1027 :                 state->mode = BAD;
; 1028 :                 break;
; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  00f3c	49 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR [r13+136]

; 1031 :             state->distbits = 6;

  00f43	49 8d 4d 74	 lea	 rcx, QWORD PTR [r13+116]

; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00f47	45 8b 85 80 00
	00 00		 mov	 r8d, DWORD PTR [r13+128]
  00f4e	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00f55	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  00f59	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00f5d	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00f63	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00f68	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00f6d	b9 02 00 00 00	 mov	 ecx, 2
  00f72	48 8d 14 45 90
	00 00 00	 lea	 rdx, QWORD PTR [rax*2+144]
  00f7a	49 03 d5	 add	 rdx, r13
  00f7d	e8 00 00 00 00	 call	 inflate_table
  00f82	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax
  00f89	44 8b f8	 mov	 r15d, eax

; 1033 :                             &(state->next), &(state->distbits), state->work);
; 1034 :             if (ret) {

  00f8c	85 c0		 test	 eax, eax
  00f8e	74 19		 je	 SHORT $LN447@inflate

; 1035 :                 strm->msg = (char *)"invalid distances set";

  00f90	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00f97	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  00f9c	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00fa4	e9 be f7 ff ff	 jmp	 $LN975@inflate
$LN447@inflate:

; 1036 :                 state->mode = BAD;
; 1037 :                 break;
; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  00fa9	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR flush$[rsp]
  00fb0	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H
  00fb8	83 f9 06	 cmp	 ecx, 6
  00fbb	0f 84 c7 06 00
	00		 je	 $LN916@inflate
  00fc1	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  00fc6	49 8d 7d 70	 lea	 rdi, QWORD PTR [r13+112]
  00fca	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]
  00fd2	45 33 ff	 xor	 r15d, r15d
  00fd5	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
$LN448@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  00fda	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H
$LN450@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  00fe2	83 fe 06	 cmp	 esi, 6
  00fe5	72 72		 jb	 SHORT $LN451@inflate
  00fe7	41 81 fb 02 01
	00 00		 cmp	 r11d, 258		; 00000102H
  00fee	72 69		 jb	 SHORT $LN451@inflate

; 1046 :                 RESTORE();

  00ff0	4d 89 54 24 10	 mov	 QWORD PTR [r12+16], r10

; 1047 :                 inflate_fast(strm, out);

  00ff5	41 8b d0	 mov	 edx, r8d
  00ff8	45 89 5c 24 18	 mov	 DWORD PTR [r12+24], r11d
  00ffd	49 8b cc	 mov	 rcx, r12
  01000	49 89 2c 24	 mov	 QWORD PTR [r12], rbp
  01004	41 89 74 24 08	 mov	 DWORD PTR [r12+8], esi
  01009	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  0100d	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  01011	e8 00 00 00 00	 call	 inflate_fast

; 1048 :                 LOAD();
; 1049 :                 if (state->mode == TYPE)

  01016	41 81 7d 08 3f
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16191 ; 00003f3fH
  0101e	4d 8b 54 24 10	 mov	 r10, QWORD PTR [r12+16]
  01023	45 8b 5c 24 18	 mov	 r11d, DWORD PTR [r12+24]
  01028	49 8b 2c 24	 mov	 rbp, QWORD PTR [r12]
  0102c	41 8b 74 24 08	 mov	 esi, DWORD PTR [r12+8]
  01031	45 8b 75 48	 mov	 r14d, DWORD PTR [r13+72]
  01035	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  01039	4c 89 54 24 40	 mov	 QWORD PTR put$1$[rsp], r10
  0103e	44 89 5c 24 30	 mov	 DWORD PTR left$1$[rsp], r11d
  01043	0f 85 28 f7 ff
	ff		 jne	 $LN8@inflate

; 1050 :                     state->back = -1;

  01049	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1051 :                 break;

  01054	e9 18 f7 ff ff	 jmp	 $LN8@inflate
$LN451@inflate:

; 1052 :             }
; 1053 :             state->back = 0;
; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  01059	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  0105b	ba 01 00 00 00	 mov	 edx, 1
  01060	4d 8b 4d 60	 mov	 r9, QWORD PTR [r13+96]
  01064	d3 e2		 shl	 edx, cl
  01066	ff ca		 dec	 edx
  01068	41 8b c6	 mov	 eax, r14d
  0106b	8b ca		 mov	 ecx, edx
  0106d	48 23 c8	 and	 rcx, rax
  01070	45 89 bd e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], r15d
  01077	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  0107b	8b c8		 mov	 ecx, eax
  0107d	c1 e9 08	 shr	 ecx, 8
  01080	0f b6 c9	 movzx	 ecx, cl

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  01083	3b cb		 cmp	 ecx, ebx
  01085	76 33		 jbe	 SHORT $LN570@inflate
$LL246@inflate:

; 1057 :                 PULLBYTE();

  01087	85 f6		 test	 esi, esi
  01089	0f 84 78 f8 ff
	ff		 je	 $LN938@inflate
  0108f	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  01093	8b cb		 mov	 ecx, ebx
  01095	d3 e0		 shl	 eax, cl
  01097	ff ce		 dec	 esi
  01099	44 03 f0	 add	 r14d, eax
  0109c	48 ff c5	 inc	 rbp
  0109f	8b c2		 mov	 eax, edx
  010a1	83 c3 08	 add	 ebx, 8
  010a4	41 8b ce	 mov	 ecx, r14d
  010a7	48 23 c8	 and	 rcx, rax
  010aa	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  010ae	8b c8		 mov	 ecx, eax
  010b0	c1 e9 08	 shr	 ecx, 8
  010b3	0f b6 c9	 movzx	 ecx, cl
  010b6	3b cb		 cmp	 ecx, ebx
  010b8	77 cd		 ja	 SHORT $LL246@inflate
$LN570@inflate:

; 1058 :             }
; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  010ba	84 c0		 test	 al, al
  010bc	0f 84 9b 00 00
	00		 je	 $LN263@inflate
  010c2	a8 f0		 test	 al, 240			; 000000f0H
  010c4	0f 85 93 00 00
	00		 jne	 $LN263@inflate

; 1060 :                 last = here;

  010ca	8b c8		 mov	 ecx, eax
  010cc	44 8b d0	 mov	 r10d, eax
  010cf	c1 e9 08	 shr	 ecx, 8

; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +

  010d2	41 bb 01 00 00
	00		 mov	 r11d, 1
  010d8	44 0f b6 c1	 movzx	 r8d, cl
  010dc	0f b6 c8	 movzx	 ecx, al
  010df	41 03 c8	 add	 ecx, r8d
  010e2	41 c1 ea 10	 shr	 r10d, 16
  010e6	41 d3 e3	 shl	 r11d, cl
  010e9	41 8b c8	 mov	 ecx, r8d
  010ec	41 8d 43 ff	 lea	 eax, DWORD PTR [r11-1]
  010f0	41 23 c6	 and	 eax, r14d
  010f3	d3 e8		 shr	 eax, cl
  010f5	41 03 c2	 add	 eax, r10d
  010f8	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  010fc	8b c8		 mov	 ecx, eax
  010fe	c1 e9 08	 shr	 ecx, 8

; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01101	0f b6 d1	 movzx	 edx, cl
  01104	41 03 d0	 add	 edx, r8d
  01107	3b d3		 cmp	 edx, ebx
  01109	76 42		 jbe	 SHORT $LN260@inflate
  0110b	0f 1f 44 00 00	 npad	 5
$LL252@inflate:

; 1065 :                     PULLBYTE();

  01110	85 f6		 test	 esi, esi
  01112	0f 84 ef f7 ff
	ff		 je	 $LN938@inflate
  01118	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  0111c	8b cb		 mov	 ecx, ebx
  0111e	d3 e0		 shl	 eax, cl
  01120	ff ce		 dec	 esi
  01122	44 03 f0	 add	 r14d, eax
  01125	41 8b c8	 mov	 ecx, r8d
  01128	41 8d 43 ff	 lea	 eax, DWORD PTR [r11-1]
  0112c	48 ff c5	 inc	 rbp
  0112f	41 23 c6	 and	 eax, r14d
  01132	83 c3 08	 add	 ebx, 8
  01135	d3 e8		 shr	 eax, cl
  01137	41 03 c2	 add	 eax, r10d
  0113a	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  0113e	8b c8		 mov	 ecx, eax
  01140	c1 e9 08	 shr	 ecx, 8
  01143	0f b6 d1	 movzx	 edx, cl
  01146	41 03 d0	 add	 edx, r8d
  01149	3b d3		 cmp	 edx, ebx
  0114b	77 c3		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1066 :                 }
; 1067 :                 DROPBITS(last.bits);

  0114d	41 8b c8	 mov	 ecx, r8d

; 1068 :                 state->back += last.bits;

  01150	45 89 85 e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], r8d
  01157	41 d3 ee	 shr	 r14d, cl
  0115a	41 2b d8	 sub	 ebx, r8d
$LN263@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);

  0115d	8b c8		 mov	 ecx, eax
  0115f	c1 e9 08	 shr	 ecx, 8
  01162	0f b6 c9	 movzx	 ecx, cl

; 1071 :             state->back += here.bits;

  01165	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
  0116c	2b d9		 sub	 ebx, ecx
  0116e	41 d3 ee	 shr	 r14d, cl

; 1072 :             state->length = (unsigned)here.val;

  01171	8b c8		 mov	 ecx, eax
  01173	c1 e9 10	 shr	 ecx, 16
  01176	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 1073 :             if ((int)(here.op) == 0) {

  0117a	84 c0		 test	 al, al
  0117c	75 0d		 jne	 SHORT $LN458@inflate

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  0117e	41 c7 45 08 4d
	3f 00 00	 mov	 DWORD PTR [r13+8], 16205 ; 00003f4dH

; 1078 :                 break;

  01186	e9 dc f5 ff ff	 jmp	 $LN975@inflate
$LN458@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  0118b	a8 20		 test	 al, 32			; 00000020H
  0118d	74 10		 je	 SHORT $LN459@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  0118f	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1083 :                 state->mode = TYPE;
; 1084 :                 break;

  0119a	e9 c0 f5 ff ff	 jmp	 $LN978@inflate
$LN459@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  0119f	a8 40		 test	 al, 64			; 00000040H
  011a1	74 19		 je	 SHORT $LN460@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  011a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  011aa	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  011af	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  011b7	e9 ab f5 ff ff	 jmp	 $LN975@inflate
$LN460@inflate:

; 1088 :                 state->mode = BAD;
; 1089 :                 break;
; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  011bc	0f b6 c8	 movzx	 ecx, al

; 1092 :             state->mode = LENEXT;

  011bf	4d 8d 4d 74	 lea	 r9, QWORD PTR [r13+116]
  011c3	83 e1 0f	 and	 ecx, 15
  011c6	41 c7 45 08 49
	3f 00 00	 mov	 DWORD PTR [r13+8], 16201 ; 00003f49H
  011ce	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN461@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  011d2	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  011d6	85 d2		 test	 edx, edx
  011d8	74 43		 je	 SHORT $LN728@inflate

; 1095 :                 NEEDBITS(state->extra);

  011da	3b da		 cmp	 ebx, edx
  011dc	73 21		 jae	 SHORT $LN264@inflate
  011de	66 90		 npad	 2
$LL267@inflate:
  011e0	85 f6		 test	 esi, esi
  011e2	0f 84 1f f7 ff
	ff		 je	 $LN938@inflate
  011e8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  011ec	8b cb		 mov	 ecx, ebx
  011ee	d3 e0		 shl	 eax, cl
  011f0	ff ce		 dec	 esi
  011f2	44 03 f0	 add	 r14d, eax
  011f5	48 ff c5	 inc	 rbp
  011f8	83 c3 08	 add	 ebx, 8
  011fb	3b da		 cmp	 ebx, edx
  011fd	72 e1		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1096 :                 state->length += BITS(state->extra);

  011ff	8b ca		 mov	 ecx, edx
  01201	b8 01 00 00 00	 mov	 eax, 1
  01206	d3 e0		 shl	 eax, cl

; 1097 :                 DROPBITS(state->extra);

  01208	2b da		 sub	 ebx, edx
  0120a	ff c8		 dec	 eax
  0120c	41 23 c6	 and	 eax, r14d
  0120f	41 d3 ee	 shr	 r14d, cl
  01212	41 01 45 50	 add	 DWORD PTR [r13+80], eax

; 1098 :                 state->back += state->extra;

  01216	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN728@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  0121d	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]
  01221	41 89 85 e8 1b
	00 00		 mov	 DWORD PTR [r13+7144], eax

; 1102 :             state->mode = DIST;

  01228	41 c7 45 08 4a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16202 ; 00003f4aH
$LN464@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  01230	41 8b 09	 mov	 ecx, DWORD PTR [r9]
  01233	ba 01 00 00 00	 mov	 edx, 1
  01238	4d 8b 4d 68	 mov	 r9, QWORD PTR [r13+104]
  0123c	d3 e2		 shl	 edx, cl
  0123e	ff ca		 dec	 edx
  01240	41 8b c6	 mov	 eax, r14d
  01243	8b ca		 mov	 ecx, edx
  01245	48 23 c8	 and	 rcx, rax
  01248	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  0124c	8b c8		 mov	 ecx, eax
  0124e	c1 e9 08	 shr	 ecx, 8
  01251	0f b6 c9	 movzx	 ecx, cl

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  01254	3b cb		 cmp	 ecx, ebx
  01256	76 33		 jbe	 SHORT $LN575@inflate
$LL275@inflate:

; 1107 :                 PULLBYTE();

  01258	85 f6		 test	 esi, esi
  0125a	0f 84 a7 f6 ff
	ff		 je	 $LN938@inflate
  01260	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  01264	8b cb		 mov	 ecx, ebx
  01266	d3 e0		 shl	 eax, cl
  01268	ff ce		 dec	 esi
  0126a	44 03 f0	 add	 r14d, eax
  0126d	48 ff c5	 inc	 rbp
  01270	41 8b ce	 mov	 ecx, r14d
  01273	83 c3 08	 add	 ebx, 8
  01276	8b c2		 mov	 eax, edx
  01278	48 23 c1	 and	 rax, rcx
  0127b	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  0127f	8b c8		 mov	 ecx, eax
  01281	c1 e9 08	 shr	 ecx, 8
  01284	0f b6 c9	 movzx	 ecx, cl
  01287	3b cb		 cmp	 ecx, ebx
  01289	77 cd		 ja	 SHORT $LL275@inflate
$LN575@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  0128b	a8 f0		 test	 al, 240			; 000000f0H
  0128d	0f 85 8e 00 00
	00		 jne	 $LN292@inflate

; 1110 :                 last = here;

  01293	8b c8		 mov	 ecx, eax
  01295	44 8b d0	 mov	 r10d, eax
  01298	c1 e9 08	 shr	 ecx, 8

; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +

  0129b	41 bb 01 00 00
	00		 mov	 r11d, 1
  012a1	44 0f b6 c1	 movzx	 r8d, cl
  012a5	0f b6 c8	 movzx	 ecx, al
  012a8	41 03 c8	 add	 ecx, r8d
  012ab	41 c1 ea 10	 shr	 r10d, 16
  012af	41 d3 e3	 shl	 r11d, cl
  012b2	41 8b c8	 mov	 ecx, r8d
  012b5	41 8d 43 ff	 lea	 eax, DWORD PTR [r11-1]
  012b9	41 23 c6	 and	 eax, r14d
  012bc	d3 e8		 shr	 eax, cl
  012be	41 03 c2	 add	 eax, r10d
  012c1	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  012c5	8b c8		 mov	 ecx, eax
  012c7	c1 e9 08	 shr	 ecx, 8

; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  012ca	0f b6 d1	 movzx	 edx, cl
  012cd	41 03 d0	 add	 edx, r8d
  012d0	3b d3		 cmp	 edx, ebx
  012d2	76 3d		 jbe	 SHORT $LN289@inflate
$LL281@inflate:

; 1115 :                     PULLBYTE();

  012d4	85 f6		 test	 esi, esi
  012d6	0f 84 2b f6 ff
	ff		 je	 $LN938@inflate
  012dc	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  012e0	8b cb		 mov	 ecx, ebx
  012e2	d3 e0		 shl	 eax, cl
  012e4	ff ce		 dec	 esi
  012e6	44 03 f0	 add	 r14d, eax
  012e9	41 8b c8	 mov	 ecx, r8d
  012ec	41 8d 43 ff	 lea	 eax, DWORD PTR [r11-1]
  012f0	48 ff c5	 inc	 rbp
  012f3	41 23 c6	 and	 eax, r14d
  012f6	83 c3 08	 add	 ebx, 8
  012f9	d3 e8		 shr	 eax, cl
  012fb	41 03 c2	 add	 eax, r10d
  012fe	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  01302	8b c8		 mov	 ecx, eax
  01304	c1 e9 08	 shr	 ecx, 8
  01307	0f b6 d1	 movzx	 edx, cl
  0130a	41 03 d0	 add	 edx, r8d
  0130d	3b d3		 cmp	 edx, ebx
  0130f	77 c3		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1116 :                 }
; 1117 :                 DROPBITS(last.bits);

  01311	41 8b c8	 mov	 ecx, r8d
  01314	41 2b d8	 sub	 ebx, r8d
  01317	41 d3 ee	 shr	 r14d, cl

; 1118 :                 state->back += last.bits;

  0131a	45 01 85 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], r8d
$LN292@inflate:

; 1119 :             }
; 1120 :             DROPBITS(here.bits);
; 1121 :             state->back += here.bits;
; 1122 :             if (here.op & 64) {

  01321	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  01326	8b c8		 mov	 ecx, eax
  01328	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
  0132d	c1 e9 08	 shr	 ecx, 8
  01330	0f b6 c9	 movzx	 ecx, cl
  01333	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
  0133a	2b d9		 sub	 ebx, ecx
  0133c	41 d3 ee	 shr	 r14d, cl
  0133f	a8 40		 test	 al, 64			; 00000040H
  01341	74 19		 je	 SHORT $LN470@inflate

; 1123 :                 strm->msg = (char *)"invalid distance code";

  01343	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  0134a	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1124 :                 state->mode = BAD;

  0134f	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1125 :                 break;

  01357	e9 15 f4 ff ff	 jmp	 $LN8@inflate
$LN470@inflate:
  0135c	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  01364	8b c8		 mov	 ecx, eax
  01366	c1 e9 10	 shr	 ecx, 16
  01369	41 89 4d 54	 mov	 DWORD PTR [r13+84], ecx

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  0136d	0f b6 c8	 movzx	 ecx, al
  01370	83 e1 0f	 and	 ecx, 15

; 1129 :             state->mode = DISTEXT;

  01373	41 c7 45 08 4b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16203 ; 00003f4bH
  0137b	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN471@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  0137f	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  01383	85 d2		 test	 edx, edx
  01385	74 46		 je	 SHORT $LN730@inflate

; 1132 :                 NEEDBITS(state->extra);

  01387	3b da		 cmp	 ebx, edx
  01389	73 24		 jae	 SHORT $LN293@inflate
  0138b	0f 1f 44 00 00	 npad	 5
$LL296@inflate:
  01390	85 f6		 test	 esi, esi
  01392	0f 84 6f f5 ff
	ff		 je	 $LN938@inflate
  01398	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  0139c	8b cb		 mov	 ecx, ebx
  0139e	d3 e0		 shl	 eax, cl
  013a0	ff ce		 dec	 esi
  013a2	44 03 f0	 add	 r14d, eax
  013a5	48 ff c5	 inc	 rbp
  013a8	83 c3 08	 add	 ebx, 8
  013ab	3b da		 cmp	 ebx, edx
  013ad	72 e1		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1133 :                 state->offset += BITS(state->extra);

  013af	8b ca		 mov	 ecx, edx
  013b1	b8 01 00 00 00	 mov	 eax, 1
  013b6	d3 e0		 shl	 eax, cl

; 1134 :                 DROPBITS(state->extra);

  013b8	2b da		 sub	 ebx, edx
  013ba	ff c8		 dec	 eax
  013bc	41 23 c6	 and	 eax, r14d
  013bf	41 d3 ee	 shr	 r14d, cl
  013c2	41 01 45 54	 add	 DWORD PTR [r13+84], eax

; 1135 :                 state->back += state->extra;

  013c6	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN730@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  013cd	41 c7 45 08 4c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16204 ; 00003f4cH
$LN474@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  013d5	45 85 db	 test	 r11d, r11d
  013d8	0f 84 29 f5 ff
	ff		 je	 $LN938@inflate

; 1148 :             copy = out - left;
; 1149 :             if (state->offset > copy) {         /* copy from window */

  013de	41 8b 45 54	 mov	 eax, DWORD PTR [r13+84]
  013e2	41 8b c8	 mov	 ecx, r8d
  013e5	41 2b cb	 sub	 ecx, r11d
  013e8	3b c1		 cmp	 eax, ecx
  013ea	76 51		 jbe	 SHORT $LN476@inflate

; 1150 :                 copy = state->offset - copy;

  013ec	2b c1		 sub	 eax, ecx

; 1151 :                 if (copy > state->whave) {

  013ee	41 3b 45 38	 cmp	 eax, DWORD PTR [r13+56]
  013f2	76 23		 jbe	 SHORT $LN479@inflate

; 1152 :                     if (state->sane) {

  013f4	41 83 bd e0 1b
	00 00 00	 cmp	 DWORD PTR [r13+7136], 0
  013fc	74 19		 je	 SHORT $LN479@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  013fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
  01405	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1154 :                         state->mode = BAD;

  0140a	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1155 :                         break;

  01412	e9 5a f3 ff ff	 jmp	 $LN8@inflate
$LN479@inflate:

; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  01417	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  0141b	3b c1		 cmp	 eax, ecx
  0141d	76 06		 jbe	 SHORT $LN480@inflate

; 1172 :                     copy -= state->wnext;

  0141f	2b c1		 sub	 eax, ecx

; 1173 :                     from = state->window + (state->wsize - copy);

  01421	41 8b 4d 34	 mov	 ecx, DWORD PTR [r13+52]
$LN480@inflate:

; 1174 :                 }
; 1175 :                 else
; 1176 :                     from = state->window + (state->wnext - copy);
; 1177 :                 if (copy > state->length) copy = state->length;

  01425	45 8b 45 50	 mov	 r8d, DWORD PTR [r13+80]
  01429	2b c8		 sub	 ecx, eax

; 1178 :             }

  0142b	41 3b c0	 cmp	 eax, r8d
  0142e	8b d1		 mov	 edx, ecx
  01430	45 8b c8	 mov	 r9d, r8d
  01433	44 0f 46 c8	 cmovbe	 r9d, eax
  01437	49 03 55 40	 add	 rdx, QWORD PTR [r13+64]
  0143b	eb 0d		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1179 :             else {                              /* copy from output */
; 1180 :                 from = put - state->offset;
; 1181 :                 copy = state->length;

  0143d	45 8b 45 50	 mov	 r8d, DWORD PTR [r13+80]
  01441	49 8b d2	 mov	 rdx, r10
  01444	48 2b d0	 sub	 rdx, rax
  01447	45 8b c8	 mov	 r9d, r8d
$LN477@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;
; 1184 :             left -= copy;

  0144a	45 3b cb	 cmp	 r9d, r11d
  0144d	41 8b cb	 mov	 ecx, r11d
  01450	41 0f 46 c9	 cmovbe	 ecx, r9d
  01454	44 2b d9	 sub	 r11d, ecx

; 1185 :             state->length -= copy;

  01457	44 2b c1	 sub	 r8d, ecx
  0145a	44 89 5c 24 30	 mov	 DWORD PTR left$1$[rsp], r11d
  0145f	49 2b d2	 sub	 rdx, r10
  01462	45 89 45 50	 mov	 DWORD PTR [r13+80], r8d
  01466	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL306@inflate:

; 1186 :             do {
; 1187 :                 *put++ = *from++;

  01470	42 0f b6 04 12	 movzx	 eax, BYTE PTR [rdx+r10]
  01475	41 88 02	 mov	 BYTE PTR [r10], al
  01478	49 ff c2	 inc	 r10

; 1188 :             } while (--copy);

  0147b	83 c1 ff	 add	 ecx, -1			; ffffffffH
  0147e	75 f0		 jne	 SHORT $LL306@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  01480	4c 89 54 24 40	 mov	 QWORD PTR put$1$[rsp], r10
  01485	41 39 4d 50	 cmp	 DWORD PTR [r13+80], ecx
  01489	0f 85 e2 f2 ff
	ff		 jne	 $LN8@inflate
  0148f	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1190 :             break;

  01497	e9 d5 f2 ff ff	 jmp	 $LN8@inflate
$LN485@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  0149c	45 85 db	 test	 r11d, r11d
  0149f	0f 84 62 f4 ff
	ff		 je	 $LN938@inflate

; 1193 :             *put++ = (unsigned char)(state->length);

  014a5	41 0f b6 45 50	 movzx	 eax, BYTE PTR [r13+80]
  014aa	41 88 02	 mov	 BYTE PTR [r10], al
  014ad	49 ff c2	 inc	 r10

; 1194 :             left--;

  014b0	41 ff cb	 dec	 r11d
  014b3	4c 89 54 24 40	 mov	 QWORD PTR put$1$[rsp], r10
  014b8	44 89 5c 24 30	 mov	 DWORD PTR left$1$[rsp], r11d

; 1195 :             state->mode = LEN;

  014bd	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1196 :             break;

  014c5	e9 a7 f2 ff ff	 jmp	 $LN8@inflate
$LN487@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  014ca	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  014cf	0f 84 e7 00 00
	00		 je	 $LN941@inflate

; 1199 :                 NEEDBITS(32);

  014d5	83 fb 20	 cmp	 ebx, 32			; 00000020H
  014d8	73 26		 jae	 SHORT $LN307@inflate
  014da	66 0f 1f 44 00
	00		 npad	 6
$LL310@inflate:
  014e0	85 f6		 test	 esi, esi
  014e2	0f 84 1f f4 ff
	ff		 je	 $LN938@inflate
  014e8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  014ec	8b cb		 mov	 ecx, ebx
  014ee	d3 e0		 shl	 eax, cl
  014f0	ff ce		 dec	 esi
  014f2	44 03 f0	 add	 r14d, eax
  014f5	48 ff c5	 inc	 rbp
  014f8	83 c3 08	 add	 ebx, 8
  014fb	83 fb 20	 cmp	 ebx, 32			; 00000020H
  014fe	72 e0		 jb	 SHORT $LL310@inflate
$LN307@inflate:

; 1200 :                 out -= left;

  01500	45 2b c3	 sub	 r8d, r11d

; 1201 :                 strm->total_out += out;

  01503	45 01 44 24 1c	 add	 DWORD PTR [r12+28], r8d

; 1202 :                 state->total += out;

  01508	45 01 45 24	 add	 DWORD PTR [r13+36], r8d

; 1203 :                 if ((state->wrap & 4) && out)

  0150c	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  01511	74 38		 je	 SHORT $LN490@inflate
  01513	45 85 c0	 test	 r8d, r8d
  01516	74 33		 je	 SHORT $LN490@inflate

; 1204 :                     strm->adler = state->check =

  01518	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0151c	49 8b d2	 mov	 rdx, r10
  0151f	41 8b c0	 mov	 eax, r8d
  01522	48 2b d0	 sub	 rdx, rax
  01525	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  0152a	74 07		 je	 SHORT $LN512@inflate
  0152c	e8 00 00 00 00	 call	 crc32
  01531	eb 05		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  01533	e8 00 00 00 00	 call	 adler32
$LN513@inflate:
  01538	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  0153d	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
  01542	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  01546	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN490@inflate:

; 1205 :                         UPDATE(state->check, put - out, out);
; 1206 :                 out = left;
; 1207 :                 if ((state->wrap & 4) && (

  0154b	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  01550	41 8b fb	 mov	 edi, r11d
  01553	44 89 9c 24 a0
	00 00 00	 mov	 DWORD PTR out$1$[rsp], r11d
  0155b	74 4f		 je	 SHORT $LN317@inflate
  0155d	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  01562	41 8b ce	 mov	 ecx, r14d
  01565	75 26		 jne	 SHORT $LN515@inflate
  01567	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0156d	41 8b c6	 mov	 eax, r14d
  01570	c1 e0 10	 shl	 eax, 16
  01573	03 c8		 add	 ecx, eax
  01575	41 8b c6	 mov	 eax, r14d
  01578	c1 e8 08	 shr	 eax, 8
  0157b	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01580	c1 e1 08	 shl	 ecx, 8
  01583	03 c8		 add	 ecx, eax
  01585	41 8b c6	 mov	 eax, r14d
  01588	c1 e8 18	 shr	 eax, 24
  0158b	03 c8		 add	 ecx, eax
$LN515@inflate:
  0158d	41 3b 4d 20	 cmp	 ecx, DWORD PTR [r13+32]
  01591	74 19		 je	 SHORT $LN317@inflate

; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {
; 1212 :                     strm->msg = (char *)"incorrect data check";

  01593	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
  0159a	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1213 :                     state->mode = BAD;

  0159f	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1214 :                     break;

  015a7	e9 c5 f1 ff ff	 jmp	 $LN8@inflate
$LN317@inflate:

; 1215 :                 }
; 1216 :                 INITBITS();

  015ac	45 8b f7	 mov	 r14d, r15d

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  015af	41 c7 45 08 4f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16207 ; 00003f4fH
  015b7	41 8b df	 mov	 ebx, r15d
  015ba	eb 18		 jmp	 SHORT $LN492@inflate
$LN941@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  015bc	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  015c3	41 c7 45 08 4f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16207 ; 00003f4fH
  015cb	eb 07		 jmp	 SHORT $LN492@inflate
$LN940@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  015cd	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]
$LN492@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  015d4	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  015d9	74 76		 je	 SHORT $LN327@inflate
  015db	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  015e0	74 6f		 je	 SHORT $LN327@inflate

; 1223 :                 NEEDBITS(32);

  015e2	83 fb 20	 cmp	 ebx, 32			; 00000020H
  015e5	73 20		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  015e7	85 f6		 test	 esi, esi
  015e9	0f 84 1f f3 ff
	ff		 je	 $LN942@inflate
  015ef	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  015f3	8b cb		 mov	 ecx, ebx
  015f5	d3 e0		 shl	 eax, cl
  015f7	ff ce		 dec	 esi
  015f9	44 03 f0	 add	 r14d, eax
  015fc	48 ff c5	 inc	 rbp
  015ff	83 c3 08	 add	 ebx, 8
  01602	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01605	72 e0		 jb	 SHORT $LL321@inflate
$LN318@inflate:

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  01607	45 3b 75 24	 cmp	 r14d, DWORD PTR [r13+36]
  0160b	74 3e		 je	 SHORT $LN328@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  0160d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
  01614	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1226 :                     state->mode = BAD;

  01619	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  01621	e9 4b f1 ff ff	 jmp	 $LN8@inflate
$LN587@inflate:

; 844  :                 RESTORE();

  01626	4d 89 54 24 10	 mov	 QWORD PTR [r12+16], r10

; 845  :                 return Z_NEED_DICT;

  0162b	b8 02 00 00 00	 mov	 eax, 2
  01630	45 89 5c 24 18	 mov	 DWORD PTR [r12+24], r11d
  01635	49 89 2c 24	 mov	 QWORD PTR [r12], rbp
  01639	41 89 74 24 08	 mov	 DWORD PTR [r12+8], esi
  0163e	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  01642	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  01646	e9 20 01 00 00	 jmp	 $LN1@inflate
$LN328@inflate:

; 1227 :                     break;
; 1228 :                 }
; 1229 :                 INITBITS();

  0164b	45 8b f7	 mov	 r14d, r15d
  0164e	41 8b df	 mov	 ebx, r15d
$LN327@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  01651	41 c7 45 08 50
	3f 00 00	 mov	 DWORD PTR [r13+8], 16208 ; 00003f50H

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  01659	41 bf 01 00 00
	00		 mov	 r15d, 1

; 1236 :             goto inf_leave;

  0165f	e9 b2 f2 ff ff	 jmp	 $LN977@inflate
$LN939@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  01664	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  0166b	41 bf 01 00 00
	00		 mov	 r15d, 1

; 1236 :             goto inf_leave;

  01671	e9 a0 f2 ff ff	 jmp	 $LN977@inflate
$LN497@inflate:
  01676	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]

; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  0167d	41 bf fd ff ff
	ff		 mov	 r15d, -3
  01683	e9 8e f2 ff ff	 jmp	 $LN977@inflate
$LN916@inflate:

; 1036 :                 state->mode = BAD;
; 1037 :                 break;
; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  01688	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]
  0168f	e9 89 f2 ff ff	 jmp	 $inf_leave$981
$LN504@inflate:

; 1259 :             return Z_MEM_ERROR;
; 1260 :         }
; 1261 :     in -= strm->avail_in;
; 1262 :     out -= strm->avail_out;

  01694	41 2b 7c 24 18	 sub	 edi, DWORD PTR [r12+24]
  01699	44 8b 54 24 3c	 mov	 r10d, DWORD PTR in$1$[rsp]
  0169e	45 2b 54 24 08	 sub	 r10d, DWORD PTR [r12+8]

; 1263 :     strm->total_in += in;

  016a3	45 01 54 24 0c	 add	 DWORD PTR [r12+12], r10d

; 1264 :     strm->total_out += out;

  016a8	41 01 7c 24 1c	 add	 DWORD PTR [r12+28], edi

; 1265 :     state->total += out;

  016ad	41 01 7d 24	 add	 DWORD PTR [r13+36], edi

; 1266 :     if ((state->wrap & 4) && out)

  016b1	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  016b6	44 89 54 24 3c	 mov	 DWORD PTR in$1$[rsp], r10d
  016bb	74 36		 je	 SHORT $LN505@inflate
  016bd	85 ff		 test	 edi, edi
  016bf	74 32		 je	 SHORT $LN505@inflate

; 1267 :         strm->adler = state->check =

  016c1	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  016c6	44 8b c7	 mov	 r8d, edi
  016c9	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  016cd	8b c7		 mov	 eax, edi
  016cf	48 2b d0	 sub	 rdx, rax
  016d2	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  016d7	74 07		 je	 SHORT $LN516@inflate
  016d9	e8 00 00 00 00	 call	 crc32
  016de	eb 05		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  016e0	e8 00 00 00 00	 call	 adler32
$LN517@inflate:
  016e5	44 8b 54 24 3c	 mov	 r10d, DWORD PTR in$1$[rsp]
  016ea	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  016ee	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN505@inflate:

; 1268 :             UPDATE(state->check, strm->next_out - out, out);
; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  016f3	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
  016f7	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  016fd	74 10		 je	 SHORT $LN518@inflate
  016ff	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  01705	74 08		 je	 SHORT $LN518@inflate
  01707	45 33 c9	 xor	 r9d, r9d
  0170a	45 8b c1	 mov	 r8d, r9d
  0170d	eb 09		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  0170f	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  01715	45 33 c9	 xor	 r9d, r9d
$LN519@inflate:
  01718	41 8b 45 0c	 mov	 eax, DWORD PTR [r13+12]
  0171c	f7 d8		 neg	 eax
  0171e	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  01723	1b c9		 sbb	 ecx, ecx
  01725	83 e1 40	 and	 ecx, 64			; 00000040H
  01728	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  0172e	44 0f 44 c8	 cmove	 r9d, eax
  01732	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  01736	44 03 c8	 add	 r9d, eax
  01739	45 03 4d 4c	 add	 r9d, DWORD PTR [r13+76]
  0173d	45 89 4c 24 48	 mov	 DWORD PTR [r12+72], r9d

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01742	45 85 d2	 test	 r10d, r10d
  01745	75 04		 jne	 SHORT $LN508@inflate
  01747	85 ff		 test	 edi, edi
  01749	74 0a		 je	 SHORT $LN507@inflate
$LN508@inflate:
  0174b	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  01753	75 0c		 jne	 SHORT $LN506@inflate
$LN507@inflate:
  01755	45 85 ff	 test	 r15d, r15d
  01758	b8 fb ff ff ff	 mov	 eax, -5
  0175d	44 0f 44 f8	 cmove	 r15d, eax
$LN506@inflate:

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;

  01761	41 8b c7	 mov	 eax, r15d
  01764	eb 05		 jmp	 SHORT $LN1@inflate
$LN333@inflate:

; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 647  :         return Z_STREAM_ERROR;

  01766	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflate:

; 1275 : }

  0176b	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  01773	48 83 c4 50	 add	 rsp, 80			; 00000050H
  01777	41 5f		 pop	 r15
  01779	41 5e		 pop	 r14
  0177b	41 5d		 pop	 r13
  0177d	41 5c		 pop	 r12
  0177f	5f		 pop	 rdi
  01780	5e		 pop	 rsi
  01781	5d		 pop	 rbp
  01782	c3		 ret	 0
  01783	90		 npad	 1
$LN820@inflate:
  01784	00 00 00 00	 DD	 $LN335@inflate
  01788	00 00 00 00	 DD	 $LN32@inflate
  0178c	00 00 00 00	 DD	 $LN46@inflate
  01790	00 00 00 00	 DD	 $LN60@inflate
  01794	00 00 00 00	 DD	 $LN361@inflate
  01798	00 00 00 00	 DD	 $LN368@inflate
  0179c	00 00 00 00	 DD	 $LN375@inflate
  017a0	00 00 00 00	 DD	 $LN384@inflate
  017a4	00 00 00 00	 DD	 $LN393@inflate
  017a8	00 00 00 00	 DD	 $LN105@inflate
  017ac	00 00 00 00	 DD	 $LN400@inflate
  017b0	00 00 00 00	 DD	 $LN402@inflate
  017b4	00 00 00 00	 DD	 $LN403@inflate
  017b8	00 00 00 00	 DD	 $LN141@inflate
  017bc	00 00 00 00	 DD	 $LN416@inflate
  017c0	00 00 00 00	 DD	 $LN418@inflate
  017c4	00 00 00 00	 DD	 $LN155@inflate
  017c8	00 00 00 00	 DD	 $LN533@inflate
  017cc	00 00 00 00	 DD	 $LN536@inflate
  017d0	00 00 00 00	 DD	 $LN448@inflate
  017d4	00 00 00 00	 DD	 $LN450@inflate
  017d8	00 00 00 00	 DD	 $LN461@inflate
  017dc	00 00 00 00	 DD	 $LN464@inflate
  017e0	00 00 00 00	 DD	 $LN471@inflate
  017e4	00 00 00 00	 DD	 $LN474@inflate
  017e8	00 00 00 00	 DD	 $LN485@inflate
  017ec	00 00 00 00	 DD	 $LN487@inflate
  017f0	00 00 00 00	 DD	 $LN940@inflate
  017f4	00 00 00 00	 DD	 $LN939@inflate
  017f8	00 00 00 00	 DD	 $LN497@inflate
  017fc	00 00 00 00	 DD	 $LN498@inflate
  01800	00 00 00 00	 DD	 $LN333@inflate
inflate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateEnd
_TEXT	SEGMENT
strm$ = 48
inflateEnd PROC						; COMDAT

; 1279 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1289 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;
; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001d	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00021	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00026	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0002b	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  0002f	48 85 d2	 test	 rdx, rdx
  00032	74 07		 je	 SHORT $LN5@inflateEnd
  00034	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00038	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN5@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  0003b	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  0003f	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00043	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1286 :     strm->state = Z_NULL;
; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  00046	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0004b	33 c0		 xor	 eax, eax
  0004d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00052	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 1289 : }

  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5b		 pop	 rbx
  0005f	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateStateCheck
_TEXT	SEGMENT
strm$ = 8
inflateStateCheck PROC					; COMDAT

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2c		 je	 SHORT $LN3@inflateSta
  00005	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  0000a	74 25		 je	 SHORT $LN3@inflateSta
  0000c	48 83 79 38 00	 cmp	 QWORD PTR [rcx+56], 0
  00011	74 1e		 je	 SHORT $LN3@inflateSta

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00013	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  00017	48 85 c0	 test	 rax, rax
  0001a	74 15		 je	 SHORT $LN3@inflateSta
  0001c	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001f	75 10		 jne	 SHORT $LN3@inflateSta
  00021	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00024	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00029	83 f8 1f	 cmp	 eax, 31
  0002c	77 03		 ja	 SHORT $LN3@inflateSta

; 115  :         return 1;
; 116  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 117  : }

  00030	c3		 ret	 0
$LN3@inflateSta:

; 111  :         return 1;

  00031	b8 01 00 00 00	 mov	 eax, 1

; 117  : }

  00036	c3		 ret	 0
inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateResetKeep
_TEXT	SEGMENT
strm$ = 48
inflateResetKeep PROC					; COMDAT

; 121  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b d1	 mov	 rdx, rcx

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	74 0a		 je	 SHORT $LN2@inflateRes
  00010	b8 fe ff ff ff	 mov	 eax, -2

; 142  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  0001e	45 33 c0	 xor	 r8d, r8d
  00021	44 89 41 24	 mov	 DWORD PTR [rcx+36], r8d
  00025	44 89 42 1c	 mov	 DWORD PTR [rdx+28], r8d
  00029	44 89 42 0c	 mov	 DWORD PTR [rdx+12], r8d

; 127  :     strm->msg = Z_NULL;

  0002d	4c 89 42 20	 mov	 QWORD PTR [rdx+32], r8

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00031	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00034	85 c0		 test	 eax, eax
  00036	74 06		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00038	83 e0 01	 and	 eax, 1
  0003b	89 42 4c	 mov	 DWORD PTR [rdx+76], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;
; 131  :     state->last = 0;
; 132  :     state->havedict = 0;
; 133  :     state->dmax = 32768U;
; 134  :     state->head = Z_NULL;
; 135  :     state->hold = 0;
; 136  :     state->bits = 0;
; 137  :     state->lencode = state->distcode = state->next = state->codes;

  0003e	48 8d 81 50 05
	00 00		 lea	 rax, QWORD PTR [rcx+1360]
  00045	48 c7 41 08 34
	3f 00 00	 mov	 QWORD PTR [rcx+8], 16180 ; 00003f34H
  0004d	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00054	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00058	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 138  :     state->sane = 1;
; 139  :     state->back = -1;
; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	44 89 41 14	 mov	 DWORD PTR [rcx+20], r8d
  00062	c7 41 1c 00 80
	00 00		 mov	 DWORD PTR [rcx+28], 32768 ; 00008000H
  00069	4c 89 41 28	 mov	 QWORD PTR [rcx+40], r8
  0006d	4c 89 41 48	 mov	 QWORD PTR [rcx+72], r8
  00071	c7 81 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rcx+7136], 1
  0007b	c7 81 e4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rcx+7140], -1

; 142  : }

  00085	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00089	c3		 ret	 0
inflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateReset2
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
inflateReset2 PROC					; COMDAT

; 160  : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	8b da		 mov	 ebx, edx
  00016	48 8b e9	 mov	 rbp, rcx

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00019	e8 00 00 00 00	 call	 inflateStateCheck
  0001e	85 c0		 test	 eax, eax
  00020	75 57		 jne	 SHORT $LN7@inflateRes

; 166  :     state = (struct inflate_state FAR *)strm->state;

  00022	48 8b 71 28	 mov	 rsi, QWORD PTR [rcx+40]

; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  00026	85 d2		 test	 edx, edx
  00028	79 06		 jns	 SHORT $LN3@inflateRes

; 170  :         wrap = 0;

  0002a	33 ff		 xor	 edi, edi

; 171  :         windowBits = -windowBits;

  0002c	f7 db		 neg	 ebx

; 172  :     }

  0002e	eb 10		 jmp	 SHORT $LN5@inflateRes
$LN3@inflateRes:

; 173  :     else {
; 174  :         wrap = (windowBits >> 4) + 5;

  00030	8b fb		 mov	 edi, ebx
  00032	c1 ef 04	 shr	 edi, 4
  00035	83 c7 05	 add	 edi, 5

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  00038	83 fb 30	 cmp	 ebx, 48			; 00000030H
  0003b	7d 03		 jge	 SHORT $LN5@inflateRes

; 177  :             windowBits &= 15;

  0003d	83 e3 0f	 and	 ebx, 15
$LN5@inflateRes:

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00040	85 db		 test	 ebx, ebx
  00042	74 08		 je	 SHORT $LN6@inflateRes
  00044	8d 43 f8	 lea	 eax, DWORD PTR [rbx-8]
  00047	83 f8 07	 cmp	 eax, 7
  0004a	77 2d		 ja	 SHORT $LN7@inflateRes
$LN6@inflateRes:

; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  0004c	48 8b 56 40	 mov	 rdx, QWORD PTR [rsi+64]
  00050	48 85 d2	 test	 rdx, rdx
  00053	74 14		 je	 SHORT $LN8@inflateRes
  00055	39 5e 30	 cmp	 DWORD PTR [rsi+48], ebx
  00058	74 0f		 je	 SHORT $LN8@inflateRes

; 185  :         ZFREE(strm, state->window);

  0005a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0005e	ff 55 38	 call	 QWORD PTR [rbp+56]

; 186  :         state->window = Z_NULL;

  00061	48 c7 46 40 00
	00 00 00	 mov	 QWORD PTR [rsi+64], 0
$LN8@inflateRes:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;
; 191  :     state->wbits = (unsigned)windowBits;
; 192  :     return inflateReset(strm);

  00069	48 8b cd	 mov	 rcx, rbp
  0006c	89 7e 10	 mov	 DWORD PTR [rsi+16], edi
  0006f	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx
  00072	e8 00 00 00 00	 call	 inflateReset
  00077	eb 05		 jmp	 SHORT $LN1@inflateRes
$LN7@inflateRes:

; 183  :         return Z_STREAM_ERROR;

  00079	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflateRes:

; 193  : }

  0007e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00083	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00088	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
inflateReset2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 8
version$ = 16
stream_size$ = 24
inflateInit_ PROC					; COMDAT

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8b c2	 mov	 r8, rdx
  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	e9 00 00 00 00	 jmp	 inflateInit2_
inflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflatePrime
_TEXT	SEGMENT
strm$ = 48
bits$ = 56
value$ = 64
inflatePrime PROC					; COMDAT

; 251  : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	45 8b d8	 mov	 r11d, r8d

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	75 46		 jne	 SHORT $LN5@inflatePri

; 255  :     state = (struct inflate_state FAR *)strm->state;

  00010	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]

; 256  :     if (bits < 0) {

  00014	85 d2		 test	 edx, edx
  00016	79 09		 jns	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  00018	49 89 41 48	 mov	 QWORD PTR [r9+72], rax

; 266  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
$LN3@inflatePri:

; 258  :         state->bits = 0;
; 259  :         return Z_OK;
; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00021	83 fa 10	 cmp	 edx, 16
  00024	7f 30		 jg	 SHORT $LN5@inflatePri
  00026	45 8b 41 4c	 mov	 r8d, DWORD PTR [r9+76]
  0002a	45 8d 14 10	 lea	 r10d, DWORD PTR [r8+rdx]
  0002e	41 83 fa 20	 cmp	 r10d, 32		; 00000020H
  00032	77 22		 ja	 SHORT $LN5@inflatePri

; 262  :     value &= (1L << bits) - 1;

  00034	8b ca		 mov	 ecx, edx

; 263  :     state->hold += (unsigned)value << state->bits;
; 264  :     state->bits += (uInt)bits;

  00036	45 89 51 4c	 mov	 DWORD PTR [r9+76], r10d
  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	d3 e0		 shl	 eax, cl
  00041	41 8b c8	 mov	 ecx, r8d
  00044	ff c8		 dec	 eax
  00046	41 23 c3	 and	 eax, r11d
  00049	d3 e0		 shl	 eax, cl
  0004b	41 01 41 48	 add	 DWORD PTR [r9+72], eax

; 265  :     return Z_OK;

  0004f	33 c0		 xor	 eax, eax

; 266  : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
$LN5@inflatePri:

; 258  :         state->bits = 0;
; 259  :         return Z_OK;
; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00056	b8 fe ff ff ff	 mov	 eax, -2

; 266  : }

  0005b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005f	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 316  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 317  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 318  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 319  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT updatewindow
_TEXT	SEGMENT
strm$ = 64
end$ = 72
copy$ = 80
updatewindow PROC					; COMDAT

; 400  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 56		 push	 r14
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;

  0000d	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00011	48 8b f2	 mov	 rsi, rdx
  00014	41 8b e8	 mov	 ebp, r8d
  00017	4c 8b d1	 mov	 r10, rcx

; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  0001a	4c 8b 4b 40	 mov	 r9, QWORD PTR [rbx+64]
  0001e	4d 85 c9	 test	 r9, r9
  00021	75 34		 jne	 SHORT $LN14@updatewind

; 408  :         state->window = (unsigned char FAR *)

  00023	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  00026	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  0002a	ba 01 00 00 00	 mov	 edx, 1
  0002f	d3 e2		 shl	 edx, cl
  00031	49 8b 4a 40	 mov	 rcx, QWORD PTR [r10+64]
  00035	41 ff 52 30	 call	 QWORD PTR [r10+48]
  00039	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax
  0003d	4c 8b c8	 mov	 r9, rax

; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));
; 411  :         if (state->window == Z_NULL) return 1;

  00040	48 85 c0	 test	 rax, rax
  00043	75 12		 jne	 SHORT $LN14@updatewind
  00045	41 8d 41 01	 lea	 eax, QWORD PTR [r9+1]

; 444  : }

  00049	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	41 5e		 pop	 r14
  00054	5e		 pop	 rsi
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
$LN14@updatewind:
  00057	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  0005c	8b 7b 34	 mov	 edi, DWORD PTR [rbx+52]
  0005f	4c 89 7c 24 48	 mov	 QWORD PTR [rsp+72], r15
  00064	45 33 ff	 xor	 r15d, r15d
  00067	85 ff		 test	 edi, edi
  00069	75 11		 jne	 SHORT $LN15@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  0006b	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  0006e	bf 01 00 00 00	 mov	 edi, 1
  00073	d3 e7		 shl	 edi, cl
  00075	89 7b 34	 mov	 DWORD PTR [rbx+52], edi

; 417  :         state->wnext = 0;
; 418  :         state->whave = 0;

  00078	4c 89 7b 38	 mov	 QWORD PTR [rbx+56], r15
$LN15@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  0007c	3b ef		 cmp	 ebp, edi
  0007e	72 1a		 jb	 SHORT $LN5@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00080	44 8b c7	 mov	 r8d, edi
  00083	49 8b c9	 mov	 rcx, r9
  00086	49 2b f0	 sub	 rsi, r8
  00089	48 8b d6	 mov	 rdx, rsi
  0008c	e8 00 00 00 00	 call	 memcpy

; 424  :         state->wnext = 0;
; 425  :         state->whave = state->wsize;

  00091	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  00094	44 89 7b 3c	 mov	 DWORD PTR [rbx+60], r15d

; 426  :     }

  00098	eb 53		 jmp	 SHORT $LN17@updatewind
$LN5@updatewind:

; 427  :     else {
; 428  :         dist = state->wsize - state->wnext;

  0009a	8b 4b 3c	 mov	 ecx, DWORD PTR [rbx+60]

; 429  :         if (dist > copy) dist = copy;
; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  0009d	48 8b d6	 mov	 rdx, rsi
  000a0	2b f9		 sub	 edi, ecx
  000a2	3b fd		 cmp	 edi, ebp
  000a4	0f 47 fd	 cmova	 edi, ebp
  000a7	48 2b d5	 sub	 rdx, rbp
  000aa	44 8b c7	 mov	 r8d, edi
  000ad	49 03 c9	 add	 rcx, r9
  000b0	e8 00 00 00 00	 call	 memcpy

; 431  :         copy -= dist;

  000b5	2b ef		 sub	 ebp, edi

; 432  :         if (copy) {

  000b7	74 1a		 je	 SHORT $LN8@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  000b9	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000bd	44 8b c5	 mov	 r8d, ebp
  000c0	49 2b f0	 sub	 rsi, r8
  000c3	48 8b d6	 mov	 rdx, rsi
  000c6	e8 00 00 00 00	 call	 memcpy

; 434  :             state->wnext = copy;
; 435  :             state->whave = state->wsize;

  000cb	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  000ce	89 6b 3c	 mov	 DWORD PTR [rbx+60], ebp

; 436  :         }

  000d1	eb 1a		 jmp	 SHORT $LN17@updatewind
$LN8@updatewind:

; 437  :         else {
; 438  :             state->wnext += dist;

  000d3	8b 4b 3c	 mov	 ecx, DWORD PTR [rbx+60]
  000d6	03 cf		 add	 ecx, edi

; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  000d8	3b 4b 34	 cmp	 ecx, DWORD PTR [rbx+52]
  000db	41 0f 44 cf	 cmove	 ecx, r15d
  000df	89 4b 3c	 mov	 DWORD PTR [rbx+60], ecx

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000e2	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  000e5	3b 4b 34	 cmp	 ecx, DWORD PTR [rbx+52]
  000e8	73 06		 jae	 SHORT $LN11@updatewind
  000ea	8d 04 39	 lea	 eax, DWORD PTR [rcx+rdi]
$LN17@updatewind:

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000ed	89 43 38	 mov	 DWORD PTR [rbx+56], eax
$LN11@updatewind:
  000f0	4c 8b 7c 24 48	 mov	 r15, QWORD PTR [rsp+72]
  000f5	33 c0		 xor	 eax, eax
  000f7	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 444  : }

  000fc	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00101	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00105	41 5e		 pop	 r14
  00107	5e		 pop	 rsi
  00108	5d		 pop	 rbp
  00109	c3		 ret	 0
updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateGetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateGetDictionary PROC				; COMDAT

; 1295 : {

$LN7:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b f2	 mov	 rsi, rdx

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00010	e8 00 00 00 00	 call	 inflateStateCheck
  00015	85 c0		 test	 eax, eax
  00017	74 10		 je	 SHORT $LN2@inflateGet
  00019	b8 fe ff ff ff	 mov	 eax, -2

; 1312 : }

  0001e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	c3		 ret	 0
$LN2@inflateGet:
  00029	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  0002e	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  00032	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00035	85 c0		 test	 eax, eax
  00037	74 2f		 je	 SHORT $LN3@inflateGet
  00039	48 85 f6	 test	 rsi, rsi
  0003c	74 2a		 je	 SHORT $LN3@inflateGet

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,

  0003e	8b 53 3c	 mov	 edx, DWORD PTR [rbx+60]
  00041	48 8b ce	 mov	 rcx, rsi
  00044	2b c2		 sub	 eax, edx
  00046	48 03 53 40	 add	 rdx, QWORD PTR [rbx+64]
  0004a	44 8b c0	 mov	 r8d, eax
  0004d	e8 00 00 00 00	 call	 memcpy

; 1305 :                 state->whave - state->wnext);
; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,

  00052	44 8b 43 3c	 mov	 r8d, DWORD PTR [rbx+60]
  00056	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00059	48 8b 53 40	 mov	 rdx, QWORD PTR [rbx+64]
  0005d	49 2b c8	 sub	 rcx, r8
  00060	48 03 ce	 add	 rcx, rsi
  00063	e8 00 00 00 00	 call	 memcpy
$LN3@inflateGet:

; 1307 :                 state->window, state->wnext);
; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  00068	48 85 ff	 test	 rdi, rdi
  0006b	74 05		 je	 SHORT $LN4@inflateGet

; 1310 :         *dictLength = state->whave;

  0006d	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00070	89 07		 mov	 DWORD PTR [rdi], eax
$LN4@inflateGet:

; 1311 :     return Z_OK;

  00072	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00077	33 c0		 xor	 eax, eax

; 1312 : }

  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
inflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateSetDictionary PROC				; COMDAT

; 1318 : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	41 8b e8	 mov	 ebp, r8d
  0001d	4c 8b f2	 mov	 r14, rdx
  00020	48 8b f1	 mov	 rsi, rcx

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00023	e8 00 00 00 00	 call	 inflateStateCheck
  00028	85 c0		 test	 eax, eax
  0002a	75 6c		 jne	 SHORT $LN10@inflateSet

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  0002c	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  00030	39 47 10	 cmp	 DWORD PTR [rdi+16], eax
  00033	74 09		 je	 SHORT $LN9@inflateSet
  00035	81 7f 08 3e 3f
	00 00		 cmp	 DWORD PTR [rdi+8], 16190 ; 00003f3eH
  0003c	75 5a		 jne	 SHORT $LN10@inflateSet
$LN9@inflateSet:

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  0003e	81 7f 08 3e 3f
	00 00		 cmp	 DWORD PTR [rdi+8], 16190 ; 00003f3eH
  00045	75 25		 jne	 SHORT $LN5@inflateSet

; 1331 :         dictid = adler32(0L, Z_NULL, 0);

  00047	45 33 c0	 xor	 r8d, r8d
  0004a	33 d2		 xor	 edx, edx
  0004c	33 c9		 xor	 ecx, ecx
  0004e	e8 00 00 00 00	 call	 adler32

; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  00053	44 8b c5	 mov	 r8d, ebp
  00056	49 8b d6	 mov	 rdx, r14
  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 adler32

; 1333 :         if (dictid != state->check)

  00060	3b 47 20	 cmp	 eax, DWORD PTR [rdi+32]
  00063	74 07		 je	 SHORT $LN5@inflateSet

; 1334 :             return Z_DATA_ERROR;

  00065	b8 fd ff ff ff	 mov	 eax, -3
  0006a	eb 31		 jmp	 SHORT $LN1@inflateSet
$LN5@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  0006c	49 8d 14 2e	 lea	 rdx, QWORD PTR [r14+rbp]
  00070	44 8b c5	 mov	 r8d, ebp
  00073	48 8b ce	 mov	 rcx, rsi
  00076	e8 00 00 00 00	 call	 updatewindow

; 1340 :     if (ret) {

  0007b	85 c0		 test	 eax, eax
  0007d	74 0e		 je	 SHORT $LN6@inflateSet

; 1341 :         state->mode = MEM;

  0007f	c7 47 08 52 3f
	00 00		 mov	 DWORD PTR [rdi+8], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  00086	b8 fc ff ff ff	 mov	 eax, -4
  0008b	eb 10		 jmp	 SHORT $LN1@inflateSet
$LN6@inflateSet:

; 1343 :     }
; 1344 :     state->havedict = 1;

  0008d	c7 47 14 01 00
	00 00		 mov	 DWORD PTR [rdi+20], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  00094	33 c0		 xor	 eax, eax
  00096	eb 05		 jmp	 SHORT $LN1@inflateSet
$LN10@inflateSet:

; 1327 :         return Z_STREAM_ERROR;

  00098	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflateSet:

; 1347 : }

  0009d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a2	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ac	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b5	41 5e		 pop	 r14
  000b7	c3		 ret	 0
inflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
strm$ = 48
head$ = 56
inflateGetHeader PROC					; COMDAT

; 1352 : {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	75 1c		 jne	 SHORT $LN5@inflateGet

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  0000d	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00011	f6 40 10 02	 test	 BYTE PTR [rax+16], 2
  00015	74 12		 je	 SHORT $LN5@inflateGet

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  00017	48 89 50 28	 mov	 QWORD PTR [rax+40], rdx

; 1362 :     head->done = 0;
; 1363 :     return Z_OK;

  0001b	33 c0		 xor	 eax, eax
  0001d	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [rdx+64], 0

; 1364 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
$LN5@inflateGet:

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2

; 1364 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT syncsearch
_TEXT	SEGMENT
have$ = 8
buf$ = 16
len$ = 24
syncsearch PROC						; COMDAT

; 1381 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00005	8b 01		 mov	 eax, DWORD PTR [rcx]

; 1386 :     next = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	45 8b d0	 mov	 r10d, r8d
  0000c	4c 8b d9	 mov	 r11, rcx
  0000f	44 8b cb	 mov	 r9d, ebx

; 1387 :     while (next < len && got < 4) {

  00012	45 85 c0	 test	 r8d, r8d
  00015	74 43		 je	 SHORT $LN13@syncsearch
$LL2@syncsearch:
  00017	83 f8 04	 cmp	 eax, 4
  0001a	73 32		 jae	 SHORT $LN14@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  0001c	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  00020	83 f8 02	 cmp	 eax, 2
  00023	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00028	0f 42 cb	 cmovb	 ecx, ebx
  0002b	44 3b c1	 cmp	 r8d, ecx
  0002e	75 04		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00030	ff c0		 inc	 eax
  00032	eb 0f		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])
; 1391 :             got = 0;
; 1392 :         else
; 1393 :             got = 4 - got;

  00034	b9 04 00 00 00	 mov	 ecx, 4
  00039	2b c8		 sub	 ecx, eax
  0003b	45 84 c0	 test	 r8b, r8b
  0003e	8b c1		 mov	 eax, ecx
  00040	0f 45 c3	 cmovne	 eax, ebx
$LN7@syncsearch:

; 1394 :         next++;

  00043	41 ff c1	 inc	 r9d
  00046	48 ff c2	 inc	 rdx
  00049	45 3b ca	 cmp	 r9d, r10d
  0004c	72 c9		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1395 :     }
; 1396 :     *have = got;
; 1397 :     return next;
; 1398 : }

  0004e	41 89 03	 mov	 DWORD PTR [r11], eax
  00051	41 8b c1	 mov	 eax, r9d
  00054	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00059	c3		 ret	 0
$LN13@syncsearch:
  0005a	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005f	89 01		 mov	 DWORD PTR [rcx], eax
  00061	41 8b c1	 mov	 eax, r9d
  00064	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSync
_TEXT	SEGMENT
strm$ = 48
buf$ = 56
inflateSync PROC					; COMDAT

; 1402 : {

$LN20:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f9	 mov	 rdi, rcx

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN4@inflateSyn
  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1441 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
$LN4@inflateSyn:

; 1410 :     state = (struct inflate_state FAR *)strm->state;
; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001d	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00021	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00026	48 8b 71 28	 mov	 rsi, QWORD PTR [rcx+40]
  0002a	75 16		 jne	 SHORT $LN15@inflateSyn
  0002c	83 7e 4c 08	 cmp	 DWORD PTR [rsi+76], 8
  00030	73 10		 jae	 SHORT $LN15@inflateSyn
  00032	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00037	b8 fb ff ff ff	 mov	 eax, -5

; 1441 : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
$LN15@inflateSyn:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00042	81 7e 08 53 3f
	00 00		 cmp	 DWORD PTR [rsi+8], 16211 ; 00003f53H
  00049	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0004e	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00053	74 67		 je	 SHORT $LN13@inflateSyn

; 1415 :         state->mode = SYNC;
; 1416 :         state->hold <<= state->bits & 7;

  00055	8b 56 4c	 mov	 edx, DWORD PTR [rsi+76]

; 1417 :         state->bits -= state->bits & 7;
; 1418 :         len = 0;

  00058	45 33 c9	 xor	 r9d, r9d
  0005b	44 8b 56 48	 mov	 r10d, DWORD PTR [rsi+72]
  0005f	8b ca		 mov	 ecx, edx
  00061	83 e1 07	 and	 ecx, 7
  00064	c7 46 08 53 3f
	00 00		 mov	 DWORD PTR [rsi+8], 16211 ; 00003f53H
  0006b	41 d3 e2	 shl	 r10d, cl
  0006e	2b d1		 sub	 edx, ecx
  00070	44 89 56 48	 mov	 DWORD PTR [rsi+72], r10d
  00074	89 56 4c	 mov	 DWORD PTR [rsi+76], edx

; 1419 :         while (state->bits >= 8) {

  00077	83 fa 08	 cmp	 edx, 8
  0007a	72 21		 jb	 SHORT $LN3@inflateSyn
  0007c	41 8b ca	 mov	 ecx, r10d
  0007f	90		 npad	 1
$LL2@inflateSyn:

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  00080	46 88 54 0c 38	 mov	 BYTE PTR buf$[rsp+r9], r10b

; 1421 :             state->hold >>= 8;
; 1422 :             state->bits -= 8;

  00085	83 c2 f8	 add	 edx, -8			; fffffff8H
  00088	c1 e9 08	 shr	 ecx, 8
  0008b	41 ff c1	 inc	 r9d
  0008e	44 0f b6 d1	 movzx	 r10d, cl
  00092	83 fa 08	 cmp	 edx, 8
  00095	73 e9		 jae	 SHORT $LL2@inflateSyn
  00097	89 56 4c	 mov	 DWORD PTR [rsi+76], edx
  0009a	89 4e 48	 mov	 DWORD PTR [rsi+72], ecx
$LN3@inflateSyn:

; 1423 :         }
; 1424 :         state->have = 0;

  0009d	48 8d 9e 84 00
	00 00		 lea	 rbx, QWORD PTR [rsi+132]

; 1425 :         syncsearch(&(state->have), buf, len);

  000a4	45 8b c1	 mov	 r8d, r9d
  000a7	48 8b cb	 mov	 rcx, rbx
  000aa	c7 03 00 00 00
	00		 mov	 DWORD PTR [rbx], 0
  000b0	48 8d 54 24 38	 lea	 rdx, QWORD PTR buf$[rsp]
  000b5	e8 00 00 00 00	 call	 syncsearch
  000ba	eb 07		 jmp	 SHORT $LN6@inflateSyn
$LN13@inflateSyn:
  000bc	48 8d 9e 84 00
	00 00		 lea	 rbx, QWORD PTR [rsi+132]
$LN6@inflateSyn:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000c3	44 8b 47 08	 mov	 r8d, DWORD PTR [rdi+8]
  000c7	48 8b cb	 mov	 rcx, rbx
  000ca	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  000cd	e8 00 00 00 00	 call	 syncsearch

; 1430 :     strm->avail_in -= len;
; 1431 :     strm->next_in += len;
; 1432 :     strm->total_in += len;

  000d2	8b 6f 0c	 mov	 ebp, DWORD PTR [rdi+12]
  000d5	29 47 08	 sub	 DWORD PTR [rdi+8], eax
  000d8	03 e8		 add	 ebp, eax
  000da	8b c8		 mov	 ecx, eax
  000dc	48 01 0f	 add	 QWORD PTR [rdi], rcx
  000df	89 6f 0c	 mov	 DWORD PTR [rdi+12], ebp

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  000e2	83 3b 04	 cmp	 DWORD PTR [rbx], 4
  000e5	74 07		 je	 SHORT $LN7@inflateSyn
  000e7	b8 fd ff ff ff	 mov	 eax, -3
  000ec	eb 1a		 jmp	 SHORT $LN18@inflateSyn
$LN7@inflateSyn:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  000ee	8b 5f 1c	 mov	 ebx, DWORD PTR [rdi+28]

; 1437 :     inflateReset(strm);

  000f1	48 8b cf	 mov	 rcx, rdi
  000f4	e8 00 00 00 00	 call	 inflateReset

; 1438 :     strm->total_in = in;  strm->total_out = out;

  000f9	89 6f 0c	 mov	 DWORD PTR [rdi+12], ebp

; 1439 :     state->mode = TYPE;
; 1440 :     return Z_OK;

  000fc	33 c0		 xor	 eax, eax
  000fe	89 5f 1c	 mov	 DWORD PTR [rdi+28], ebx
  00101	c7 46 08 3f 3f
	00 00		 mov	 DWORD PTR [rsi+8], 16191 ; 00003f3fH
$LN18@inflateSyn:
  00108	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0010d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00112	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 1441 : }

  00117	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011b	5f		 pop	 rdi
  0011c	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
strm$ = 48
inflateSyncPoint PROC					; COMDAT

; 1453 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateSyn
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1459 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1458 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 08 41 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16193 ; 00003f41H
  00022	75 10		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00028	75 0a		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1459 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN4@inflateSyn:

; 1458 :     return state->mode == STORED && state->bits == 0;

  00034	33 c0		 xor	 eax, eax

; 1459 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateCopy
_TEXT	SEGMENT
dest$ = 64
source$ = 72
inflateCopy PROC					; COMDAT

; 1464 : {

$LN19:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00007	48 8b e9	 mov	 rbp, rcx
  0000a	48 8b fa	 mov	 rdi, rdx

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 inflateStateCheck
  00015	85 c0		 test	 eax, eax
  00017	0f 85 84 01 00
	00		 jne	 $LN3@inflateCop
  0001d	48 85 ed	 test	 rbp, rbp
  00020	0f 84 7b 01 00
	00		 je	 $LN3@inflateCop

; 1473 :     state = (struct inflate_state FAR *)source->state;
; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)

  00026	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002a	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  00030	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00035	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0003a	48 8b 72 28	 mov	 rsi, QWORD PTR [rdx+40]
  0003e	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  00043	41 be 01 00 00
	00		 mov	 r14d, 1
  00049	41 8b d6	 mov	 edx, r14d
  0004c	ff 57 30	 call	 QWORD PTR [rdi+48]
  0004f	48 8b d8	 mov	 rbx, rax

; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00052	48 85 c0	 test	 rax, rax
  00055	75 05		 jne	 SHORT $LN4@inflateCop
  00057	8d 43 fc	 lea	 eax, QWORD PTR [rbx-4]
  0005a	eb 45		 jmp	 SHORT $LN15@inflateCop
$LN4@inflateCop:
  0005c	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00061	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 1479 :     window = Z_NULL;

  00066	45 33 ff	 xor	 r15d, r15d

; 1480 :     if (state->window != Z_NULL) {

  00069	4c 39 7e 40	 cmp	 QWORD PTR [rsi+64], r15
  0006d	74 48		 je	 SHORT $LN11@inflateCop

; 1481 :         window = (unsigned char FAR *)

  0006f	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]
  00072	41 8b d6	 mov	 edx, r14d
  00075	d3 e2		 shl	 edx, cl
  00077	45 8b c6	 mov	 r8d, r14d
  0007a	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  0007e	ff 57 30	 call	 QWORD PTR [rdi+48]
  00081	4c 8b f8	 mov	 r15, rax

; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1483 :         if (window == Z_NULL) {

  00084	48 85 c0	 test	 rax, rax
  00087	75 2e		 jne	 SHORT $LN11@inflateCop

; 1484 :             ZFREE(source, copy);

  00089	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  0008d	48 8b d3	 mov	 rdx, rbx
  00090	ff 57 38	 call	 QWORD PTR [rdi+56]

; 1485 :             return Z_MEM_ERROR;

  00093	41 8d 47 fc	 lea	 eax, QWORD PTR [r15-4]
$LN17@inflateCop:
  00097	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  0009c	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
$LN15@inflateCop:
  000a1	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ab	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]

; 1506 : }

  000b0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b4	5f		 pop	 rdi
  000b5	5d		 pop	 rbp
  000b6	c3		 ret	 0
$LN11@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  000b7	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000ba	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  000c0	48 8b d6	 mov	 rdx, rsi
  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	0f 11 45 00	 movups	 XMMWORD PTR [rbp], xmm0
  000ca	0f 10 4f 10	 movups	 xmm1, XMMWORD PTR [rdi+16]
  000ce	0f 11 4d 10	 movups	 XMMWORD PTR [rbp+16], xmm1
  000d2	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [rdi+32]
  000d6	0f 11 45 20	 movups	 XMMWORD PTR [rbp+32], xmm0
  000da	0f 10 4f 30	 movups	 xmm1, XMMWORD PTR [rdi+48]
  000de	0f 11 4d 30	 movups	 XMMWORD PTR [rbp+48], xmm1
  000e2	0f 10 47 40	 movups	 xmm0, XMMWORD PTR [rdi+64]
  000e6	0f 11 45 40	 movups	 XMMWORD PTR [rbp+64], xmm0
  000ea	f2 0f 10 4f 50	 movsd	 xmm1, QWORD PTR [rdi+80]
  000ef	f2 0f 11 4d 50	 movsd	 QWORD PTR [rbp+80], xmm1
  000f4	e8 00 00 00 00	 call	 memcpy

; 1492 :     copy->strm = dest;

  000f9	48 89 2b	 mov	 QWORD PTR [rbx], rbp

; 1493 :     if (state->lencode >= state->codes &&

  000fc	48 8d 86 50 05
	00 00		 lea	 rax, QWORD PTR [rsi+1360]
  00103	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00107	48 3b c8	 cmp	 rcx, rax
  0010a	72 47		 jb	 SHORT $LN7@inflateCop
  0010c	48 8d 86 dc 1b
	00 00		 lea	 rax, QWORD PTR [rsi+7132]
  00113	48 3b c8	 cmp	 rcx, rax
  00116	77 3b		 ja	 SHORT $LN7@inflateCop

; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  00118	48 2b ce	 sub	 rcx, rsi
  0011b	48 8d 81 b0 fa
	ff ff		 lea	 rax, QWORD PTR [rcx-1360]
  00122	48 c1 f8 02	 sar	 rax, 2
  00126	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  0012c	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  00130	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00134	48 8b 46 68	 mov	 rax, QWORD PTR [rsi+104]
  00138	48 2b c6	 sub	 rax, rsi
  0013b	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  00141	48 c1 f8 02	 sar	 rax, 2
  00145	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  0014b	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  0014f	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax
$LN7@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  00153	48 8b 86 88 00
	00 00		 mov	 rax, QWORD PTR [rsi+136]
  0015a	48 2b c6	 sub	 rax, rsi
  0015d	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  00163	48 c1 f8 02	 sar	 rax, 2
  00167	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  0016d	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  00171	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 1499 :     if (window != Z_NULL) {

  00178	4d 85 ff	 test	 r15, r15
  0017b	74 15		 je	 SHORT $LN8@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  0017d	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]

; 1501 :         zmemcpy(window, state->window, wsize);

  00180	48 8b 56 40	 mov	 rdx, QWORD PTR [rsi+64]
  00184	41 d3 e6	 shl	 r14d, cl
  00187	49 8b cf	 mov	 rcx, r15
  0018a	45 8b c6	 mov	 r8d, r14d
  0018d	e8 00 00 00 00	 call	 memcpy
$LN8@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;

  00192	4c 89 7b 40	 mov	 QWORD PTR [rbx+64], r15

; 1504 :     dest->state = (struct internal_state FAR *)copy;
; 1505 :     return Z_OK;

  00196	33 c0		 xor	 eax, eax
  00198	48 89 5d 28	 mov	 QWORD PTR [rbp+40], rbx
  0019c	e9 f6 fe ff ff	 jmp	 $LN17@inflateCop
$LN3@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  001a1	b8 fe ff ff ff	 mov	 eax, -2

; 1506 : }

  001a6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001aa	5f		 pop	 rdi
  001ab	5d		 pop	 rbp
  001ac	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateUndermine
_TEXT	SEGMENT
strm$ = 48
subvert$ = 56
inflateUndermine PROC					; COMDAT

; 1511 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateUnd
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1523 : #endif
; 1524 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;
; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  0001b	c7 80 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7136], 1

; 1522 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3

; 1523 : #endif
; 1524 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateValidate
_TEXT	SEGMENT
strm$ = 48
check$ = 56
inflateValidate PROC					; COMDAT

; 1529 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	44 8b c2	 mov	 r8d, edx

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	74 0a		 je	 SHORT $LN2@inflateVal
  00010	b8 fe ff ff ff	 mov	 eax, -2

; 1539 : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
$LN2@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;

  0001a	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  0001e	8b 4a 10	 mov	 ecx, DWORD PTR [rdx+16]

; 1534 :     if (check)
; 1535 :         state->wrap |= 4;
; 1536 :     else
; 1537 :         state->wrap &= ~4;
; 1538 :     return Z_OK;

  00021	8b c1		 mov	 eax, ecx
  00023	83 e0 fb	 and	 eax, -5
  00026	83 c9 04	 or	 ecx, 4
  00029	45 85 c0	 test	 r8d, r8d
  0002c	0f 44 c8	 cmove	 ecx, eax
  0002f	33 c0		 xor	 eax, eax
  00031	89 4a 10	 mov	 DWORD PTR [rdx+16], ecx

; 1539 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
inflateValidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateMark
_TEXT	SEGMENT
strm$ = 48
inflateMark PROC					; COMDAT

; 1543 : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateMar

; 1547 :         return -(1L << 16);

  0000d	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 13		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  00029	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  0002f	c1 e0 10	 shl	 eax, 16
  00032	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
$LN6@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00039	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003f	75 19		 jne	 SHORT $LN4@inflateMar
  00041	8b 88 e8 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7144]
  00047	2b 48 50	 sub	 ecx, DWORD PTR [rax+80]
  0004a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00050	c1 e0 10	 shl	 eax, 16
  00053	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
$LN4@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0005a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00060	33 c9		 xor	 ecx, ecx
  00062	c1 e0 10	 shl	 eax, 16
  00065	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateCodesUsed
_TEXT	SEGMENT
strm$ = 48
inflateCodesUsed PROC					; COMDAT

; 1556 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateCod
  0000d	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH

; 1561 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 1560 :     return (unsigned long)(state->next - state->codes);

  0001b	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]
  00022	48 2b c1	 sub	 rax, rcx
  00025	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  0002b	48 c1 f8 02	 sar	 rax, 2

; 1561 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
inflateCodesUsed ENDP
_TEXT	ENDS
END
