; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31107.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	inflate_fast
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_fast DD imagerel $LN107
	DD	imagerel $LN107+1244
	DD	imagerel $unwind$inflate_fast
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_fast DD 091501H
	DD	0f0116215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inffast.c
;	COMDAT inflate_fast
_TEXT	SEGMENT
tv1185 = 0
dcode$1$ = 8
last$1$ = 16
end$1$ = 24
beg$1$ = 32
strm$ = 128
wsize$1$ = 136
start$ = 136
tv1184 = 144
whave$1$ = 152
inflate_fast PROC					; COMDAT

; 53   : {

$LN107:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 54   :     struct inflate_state FAR *state;
; 55   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 56   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 57   :     unsigned char FAR *out;     /* local strm->next_out */
; 58   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 59   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 60   : #ifdef INFLATE_STRICT
; 61   :     unsigned dmax;              /* maximum distance from zlib header */
; 62   : #endif
; 63   :     unsigned wsize;             /* window size or zero if not using window */
; 64   :     unsigned whave;             /* valid bytes in the window */
; 65   :     unsigned wnext;             /* window write index */
; 66   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 67   :     unsigned long hold;         /* local strm->hold */
; 68   :     unsigned bits;              /* local strm->bits */
; 69   :     code const FAR *lcode;      /* local strm->lencode */
; 70   :     code const FAR *dcode;      /* local strm->distcode */
; 71   :     unsigned lmask;             /* mask for first level of length codes */
; 72   :     unsigned dmask;             /* mask for first level of distance codes */
; 73   :     code here;                  /* retrieved table entry */
; 74   :     unsigned op;                /* code bits, operation, extra bits, or */
; 75   :                                 /*  window position, window bytes to copy */
; 76   :     unsigned len;               /* match length, unused bytes */
; 77   :     unsigned dist;              /* match distance */
; 78   :     unsigned char FAR *from;    /* where to copy match from */
; 79   : 
; 80   :     /* copy state to local variables */
; 81   :     state = (struct inflate_state FAR *)strm->state;

  00015	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]

; 82   :     in = strm->next_in;
; 83   :     last = in + (strm->avail_in - 5);
; 84   :     out = strm->next_out;
; 85   :     beg = out - (start - strm->avail_out);
; 86   :     end = out + (strm->avail_out - 257);
; 87   : #ifdef INFLATE_STRICT
; 88   :     dmax = state->dmax;
; 89   : #endif
; 90   :     wsize = state->wsize;
; 91   :     whave = state->whave;
; 92   :     wnext = state->wnext;
; 93   :     window = state->window;
; 94   :     hold = state->hold;
; 95   :     bits = state->bits;
; 96   :     lcode = state->lencode;
; 97   :     dcode = state->distcode;
; 98   :     lmask = (1U << state->lenbits) - 1;

  00019	bd 01 00 00 00	 mov	 ebp, 1
  0001e	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00021	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00025	83 e8 05	 sub	 eax, 5
  00028	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  0002b	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0002e	48 03 c6	 add	 rax, rsi
  00031	49 8b 7d 68	 mov	 rdi, QWORD PTR [r13+104]
  00035	2b d1		 sub	 edx, ecx
  00037	45 8b 75 3c	 mov	 r14d, DWORD PTR [r13+60]
  0003b	4d 8b 7d 40	 mov	 r15, QWORD PTR [r13+64]
  0003f	41 8b 5d 48	 mov	 ebx, DWORD PTR [r13+72]
  00043	45 8b 5d 4c	 mov	 r11d, DWORD PTR [r13+76]
  00047	4d 8b 65 60	 mov	 r12, QWORD PTR [r13+96]
  0004b	48 89 44 24 10	 mov	 QWORD PTR last$1$[rsp], rax
  00050	8b c2		 mov	 eax, edx
  00052	49 8b d0	 mov	 rdx, r8
  00055	48 2b d0	 sub	 rdx, rax
  00058	48 89 7c 24 08	 mov	 QWORD PTR dcode$1$[rsp], rdi
  0005d	8d 81 ff fe ff
	ff		 lea	 eax, DWORD PTR [rcx-257]
  00063	48 89 54 24 20	 mov	 QWORD PTR beg$1$[rsp], rdx
  00068	41 8b 4d 70	 mov	 ecx, DWORD PTR [r13+112]
  0006c	49 03 c0	 add	 rax, r8
  0006f	48 89 44 24 18	 mov	 QWORD PTR end$1$[rsp], rax
  00074	8b d5		 mov	 edx, ebp
  00076	41 8b 45 34	 mov	 eax, DWORD PTR [r13+52]
  0007a	89 84 24 88 00
	00 00		 mov	 DWORD PTR wsize$1$[rsp], eax
  00081	41 8b 45 38	 mov	 eax, DWORD PTR [r13+56]
  00085	89 84 24 98 00
	00 00		 mov	 DWORD PTR whave$1$[rsp], eax

; 99   :     dmask = (1U << state->distbits) - 1;

  0008c	8b c5		 mov	 eax, ebp
  0008e	d3 e2		 shl	 edx, cl
  00090	41 8b 4d 74	 mov	 ecx, DWORD PTR [r13+116]
  00094	ff ca		 dec	 edx
  00096	d3 e0		 shl	 eax, cl
  00098	ff c8		 dec	 eax
  0009a	89 14 24	 mov	 DWORD PTR tv1185[rsp], edx
  0009d	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv1184[rsp], eax
$LL4@inflate_fa:

; 100  : 
; 101  :     /* decode literals and length/distances until end-of-block or not enough
; 102  :        input data or output space */
; 103  :     do {
; 104  :         if (bits < 15) {

  000a4	41 83 fb 0f	 cmp	 r11d, 15
  000a8	73 1e		 jae	 SHORT $LN22@inflate_fa

; 105  :             hold += (unsigned long)(*in++) << bits;

  000aa	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  000ad	41 8b cb	 mov	 ecx, r11d
  000b0	d3 e0		 shl	 eax, cl

; 106  :             bits += 8;
; 107  :             hold += (unsigned long)(*in++) << bits;

  000b2	41 8d 4b 08	 lea	 ecx, DWORD PTR [r11+8]
  000b6	03 d8		 add	 ebx, eax
  000b8	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  000bc	d3 e0		 shl	 eax, cl
  000be	03 d8		 add	 ebx, eax
  000c0	48 83 c6 02	 add	 rsi, 2

; 108  :             bits += 8;

  000c4	41 83 c3 10	 add	 r11d, 16
$LN22@inflate_fa:

; 109  :         }
; 110  :         here = lcode[hold & lmask];

  000c8	8b c3		 mov	 eax, ebx
  000ca	8b ca		 mov	 ecx, edx
  000cc	48 23 c8	 and	 rcx, rax
  000cf	41 8b 04 8c	 mov	 eax, DWORD PTR [r12+rcx*4]
  000d3	8b c8		 mov	 ecx, eax
  000d5	c1 e9 08	 shr	 ecx, 8
  000d8	0f b6 c9	 movzx	 ecx, cl

; 111  :       dolen:
; 112  :         op = (unsigned)(here.bits);
; 113  :         hold >>= op;

  000db	d3 eb		 shr	 ebx, cl

; 114  :         bits -= op;

  000dd	44 2b d9	 sub	 r11d, ecx
  000e0	0f b6 d0	 movzx	 edx, al

; 115  :         op = (unsigned)(here.op);
; 116  :         if (op == 0) {                          /* literal */

  000e3	84 c0		 test	 al, al
  000e5	74 46		 je	 SHORT $LN72@inflate_fa
  000e7	c1 e8 10	 shr	 eax, 16
  000ea	44 8b c8	 mov	 r9d, eax
  000ed	44 8b d0	 mov	 r10d, eax
$dolen$108:

; 121  :         }
; 122  :         else if (op & 16) {                     /* length base */

  000f0	f6 c2 10	 test	 dl, 16
  000f3	75 46		 jne	 SHORT $LN73@inflate_fa

; 272  :                 state->mode = BAD;
; 273  :                 break;
; 274  :             }
; 275  :         }
; 276  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000f5	f6 c2 40	 test	 dl, 64			; 00000040H
  000f8	0f 85 29 03 00
	00		 jne	 $LN52@inflate_fa

; 277  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  000fe	8b ca		 mov	 ecx, edx
  00100	8b c5		 mov	 eax, ebp
  00102	d3 e0		 shl	 eax, cl
  00104	ff c8		 dec	 eax
  00106	23 c3		 and	 eax, ebx
  00108	41 03 c1	 add	 eax, r9d
  0010b	41 8b 04 84	 mov	 eax, DWORD PTR [r12+rax*4]
  0010f	8b c8		 mov	 ecx, eax
  00111	c1 e9 08	 shr	 ecx, 8
  00114	44 8b c8	 mov	 r9d, eax
  00117	0f b6 c9	 movzx	 ecx, cl
  0011a	41 c1 e9 10	 shr	 r9d, 16
  0011e	44 2b d9	 sub	 r11d, ecx
  00121	d3 eb		 shr	 ebx, cl
  00123	45 8b d1	 mov	 r10d, r9d
  00126	0f b6 d0	 movzx	 edx, al
  00129	84 c0		 test	 al, al
  0012b	75 c3		 jne	 SHORT $dolen$108
$LN72@inflate_fa:

; 117  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 118  :                     "inflate:         literal '%c'\n" :
; 119  :                     "inflate:         literal 0x%02x\n", here.val));
; 120  :             *out++ = (unsigned char)(here.val);

  0012d	c1 e8 10	 shr	 eax, 16
  00130	41 88 00	 mov	 BYTE PTR [r8], al
  00133	49 ff c0	 inc	 r8

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  00136	e9 d6 02 00 00	 jmp	 $LN2@inflate_fa
$LN73@inflate_fa:

; 123  :             len = (unsigned)(here.val);
; 124  :             op &= 15;                           /* number of extra bits */

  0013b	83 e2 0f	 and	 edx, 15

; 125  :             if (op) {

  0013e	74 28		 je	 SHORT $LN27@inflate_fa

; 126  :                 if (bits < op) {

  00140	44 3b da	 cmp	 r11d, edx
  00143	73 11		 jae	 SHORT $LN28@inflate_fa

; 127  :                     hold += (unsigned long)(*in++) << bits;

  00145	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00148	41 8b cb	 mov	 ecx, r11d
  0014b	d3 e0		 shl	 eax, cl
  0014d	48 ff c6	 inc	 rsi
  00150	03 d8		 add	 ebx, eax

; 128  :                     bits += 8;

  00152	41 83 c3 08	 add	 r11d, 8
$LN28@inflate_fa:

; 129  :                 }
; 130  :                 len += (unsigned)hold & ((1U << op) - 1);

  00156	8b ca		 mov	 ecx, edx
  00158	8b c5		 mov	 eax, ebp
  0015a	d3 e0		 shl	 eax, cl
  0015c	ff c8		 dec	 eax
  0015e	23 c3		 and	 eax, ebx

; 131  :                 hold >>= op;

  00160	d3 eb		 shr	 ebx, cl
  00162	44 03 d0	 add	 r10d, eax

; 132  :                 bits -= op;

  00165	44 2b da	 sub	 r11d, edx
$LN27@inflate_fa:

; 133  :             }
; 134  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 135  :             if (bits < 15) {

  00168	41 83 fb 0f	 cmp	 r11d, 15
  0016c	73 1e		 jae	 SHORT $LN29@inflate_fa

; 136  :                 hold += (unsigned long)(*in++) << bits;

  0016e	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00171	41 8b cb	 mov	 ecx, r11d
  00174	d3 e0		 shl	 eax, cl

; 137  :                 bits += 8;
; 138  :                 hold += (unsigned long)(*in++) << bits;

  00176	41 8d 4b 08	 lea	 ecx, DWORD PTR [r11+8]
  0017a	03 d8		 add	 ebx, eax
  0017c	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  00180	d3 e0		 shl	 eax, cl
  00182	03 d8		 add	 ebx, eax
  00184	48 83 c6 02	 add	 rsi, 2

; 139  :                 bits += 8;

  00188	41 83 c3 10	 add	 r11d, 16
$LN29@inflate_fa:

; 140  :             }
; 141  :             here = dcode[hold & dmask];

  0018c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv1184[rsp]
  00193	8b c3		 mov	 eax, ebx
  00195	48 23 c8	 and	 rcx, rax
  00198	8b 14 8f	 mov	 edx, DWORD PTR [rdi+rcx*4]
  0019b	8b c2		 mov	 eax, edx
  0019d	c1 e8 08	 shr	 eax, 8
  001a0	8b fa		 mov	 edi, edx
  001a2	0f b6 c8	 movzx	 ecx, al

; 142  :           dodist:
; 143  :             op = (unsigned)(here.bits);
; 144  :             hold >>= op;

  001a5	d3 eb		 shr	 ebx, cl

; 145  :             bits -= op;

  001a7	44 2b d9	 sub	 r11d, ecx
  001aa	c1 ef 10	 shr	 edi, 16
  001ad	44 0f b6 ca	 movzx	 r9d, dl

; 146  :             op = (unsigned)(here.op);
; 147  :             if (op & 16) {                      /* distance base */

  001b1	41 f6 c1 10	 test	 r9b, 16
  001b5	75 44		 jne	 SHORT $LN74@inflate_fa
  001b7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$dodist$109:

; 263  :                     }
; 264  :                 }
; 265  :             }
; 266  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001c0	41 f6 c1 40	 test	 r9b, 64			; 00000040H
  001c4	0f 85 89 02 00
	00		 jne	 $LN50@inflate_fa

; 267  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  001ca	41 8b c9	 mov	 ecx, r9d
  001cd	8b c5		 mov	 eax, ebp
  001cf	d3 e0		 shl	 eax, cl
  001d1	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dcode$1$[rsp]
  001d6	ff c8		 dec	 eax
  001d8	23 c3		 and	 eax, ebx
  001da	03 c7		 add	 eax, edi
  001dc	8b 14 81	 mov	 edx, DWORD PTR [rcx+rax*4]
  001df	8b c2		 mov	 eax, edx
  001e1	c1 e8 08	 shr	 eax, 8
  001e4	8b fa		 mov	 edi, edx
  001e6	0f b6 c8	 movzx	 ecx, al
  001e9	d3 eb		 shr	 ebx, cl
  001eb	44 2b d9	 sub	 r11d, ecx
  001ee	c1 ef 10	 shr	 edi, 16
  001f1	44 0f b6 ca	 movzx	 r9d, dl
  001f5	41 f6 c1 10	 test	 r9b, 16
  001f9	74 c5		 je	 SHORT $dodist$109
$LN74@inflate_fa:

; 148  :                 dist = (unsigned)(here.val);
; 149  :                 op &= 15;                       /* number of extra bits */

  001fb	41 83 e1 0f	 and	 r9d, 15

; 150  :                 if (bits < op) {

  001ff	45 3b d9	 cmp	 r11d, r9d
  00202	73 27		 jae	 SHORT $LN33@inflate_fa

; 151  :                     hold += (unsigned long)(*in++) << bits;

  00204	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00207	41 8b cb	 mov	 ecx, r11d
  0020a	d3 e0		 shl	 eax, cl

; 152  :                     bits += 8;

  0020c	41 83 c3 08	 add	 r11d, 8
  00210	03 d8		 add	 ebx, eax
  00212	48 ff c6	 inc	 rsi

; 153  :                     if (bits < op) {

  00215	45 3b d9	 cmp	 r11d, r9d
  00218	73 11		 jae	 SHORT $LN33@inflate_fa

; 154  :                         hold += (unsigned long)(*in++) << bits;

  0021a	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0021d	41 8b cb	 mov	 ecx, r11d
  00220	d3 e0		 shl	 eax, cl
  00222	03 d8		 add	 ebx, eax
  00224	48 ff c6	 inc	 rsi

; 155  :                         bits += 8;

  00227	41 83 c3 08	 add	 r11d, 8
$LN33@inflate_fa:

; 156  :                     }
; 157  :                 }
; 158  :                 dist += (unsigned)hold & ((1U << op) - 1);

  0022b	41 8b c9	 mov	 ecx, r9d
  0022e	8b d5		 mov	 edx, ebp
  00230	d3 e2		 shl	 edx, cl

; 159  : #ifdef INFLATE_STRICT
; 160  :                 if (dist > dmax) {
; 161  :                     strm->msg = (char *)"invalid distance too far back";
; 162  :                     state->mode = BAD;
; 163  :                     break;
; 164  :                 }
; 165  : #endif
; 166  :                 hold >>= op;
; 167  :                 bits -= op;
; 168  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 169  :                 op = (unsigned)(out - beg);     /* max distance in output */

  00232	41 8b c0	 mov	 eax, r8d
  00235	2b 44 24 20	 sub	 eax, DWORD PTR beg$1$[rsp]
  00239	ff ca		 dec	 edx
  0023b	23 d3		 and	 edx, ebx
  0023d	45 2b d9	 sub	 r11d, r9d
  00240	03 d7		 add	 edx, edi
  00242	d3 eb		 shr	 ebx, cl

; 170  :                 if (dist > op) {                /* see if copy from window */

  00244	3b d0		 cmp	 edx, eax
  00246	0f 86 64 01 00
	00		 jbe	 $LN34@inflate_fa

; 171  :                     op = dist - op;             /* distance back in window */

  0024c	8b ca		 mov	 ecx, edx
  0024e	2b c8		 sub	 ecx, eax

; 172  :                     if (op > whave) {

  00250	3b 8c 24 98 00
	00 00		 cmp	 ecx, DWORD PTR whave$1$[rsp]
  00257	76 0e		 jbe	 SHORT $LN37@inflate_fa

; 173  :                         if (state->sane) {

  00259	41 83 bd e0 1b
	00 00 00	 cmp	 DWORD PTR [r13+7136], 0
  00261	0f 85 09 02 00
	00		 jne	 $LN75@inflate_fa
$LN37@inflate_fa:

; 175  :                                 (char *)"invalid distance too far back";
; 176  :                             state->mode = BAD;
; 177  :                             break;
; 178  :                         }
; 179  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 180  :                         if (len <= op - whave) {
; 181  :                             do {
; 182  :                                 *out++ = 0;
; 183  :                             } while (--len);
; 184  :                             continue;
; 185  :                         }
; 186  :                         len -= op - whave;
; 187  :                         do {
; 188  :                             *out++ = 0;
; 189  :                         } while (--op > whave);
; 190  :                         if (op == 0) {
; 191  :                             from = out - dist;
; 192  :                             do {
; 193  :                                 *out++ = *from++;
; 194  :                             } while (--len);
; 195  :                             continue;
; 196  :                         }
; 197  : #endif
; 198  :                     }
; 199  :                     from = window;
; 200  :                     if (wnext == 0) {           /* very common case */

  00267	45 85 f6	 test	 r14d, r14d
  0026a	75 3c		 jne	 SHORT $LN38@inflate_fa

; 201  :                         from += wsize - op;

  0026c	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR wsize$1$[rsp]
  00274	44 2b c9	 sub	 r9d, ecx
  00277	4d 03 cf	 add	 r9, r15

; 202  :                         if (op < len) {         /* some from window */

  0027a	41 3b ca	 cmp	 ecx, r10d
  0027d	0f 83 b8 00 00
	00		 jae	 $LN69@inflate_fa

; 203  :                             len -= op;

  00283	44 2b d1	 sub	 r10d, ecx
  00286	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@inflate_fa:

; 204  :                             do {
; 205  :                                 *out++ = *from++;

  00290	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00294	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00298	41 88 00	 mov	 BYTE PTR [r8], al
  0029b	49 ff c0	 inc	 r8

; 206  :                             } while (--op);

  0029e	83 c1 ff	 add	 ecx, -1			; ffffffffH
  002a1	75 ed		 jne	 SHORT $LL7@inflate_fa

; 207  :                             from = out - dist;  /* rest from output */
; 208  :                         }
; 209  :                     }

  002a3	e9 8b 00 00 00	 jmp	 $LN104@inflate_fa
$LN38@inflate_fa:

; 210  :                     else if (wnext < op) {      /* wrap around window */

  002a8	41 8b c6	 mov	 eax, r14d
  002ab	2b c1		 sub	 eax, ecx
  002ad	44 3b f1	 cmp	 r14d, ecx
  002b0	73 53		 jae	 SHORT $LN41@inflate_fa

; 211  :                         from += wsize + wnext - op;

  002b2	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR wsize$1$[rsp]

; 212  :                         op -= wnext;

  002ba	41 2b ce	 sub	 ecx, r14d
  002bd	44 03 c8	 add	 r9d, eax
  002c0	4d 03 cf	 add	 r9, r15

; 213  :                         if (op < len) {         /* some from end of window */

  002c3	41 3b ca	 cmp	 ecx, r10d
  002c6	73 73		 jae	 SHORT $LN69@inflate_fa

; 214  :                             len -= op;

  002c8	44 2b d1	 sub	 r10d, ecx
  002cb	4d 2b c8	 sub	 r9, r8
  002ce	66 90		 npad	 2
$LL10@inflate_fa:

; 215  :                             do {
; 216  :                                 *out++ = *from++;

  002d0	43 0f b6 04 01	 movzx	 eax, BYTE PTR [r9+r8]
  002d5	41 88 00	 mov	 BYTE PTR [r8], al
  002d8	49 ff c0	 inc	 r8

; 217  :                             } while (--op);

  002db	83 c1 ff	 add	 ecx, -1			; ffffffffH
  002de	75 f0		 jne	 SHORT $LL10@inflate_fa

; 218  :                             from = window;

  002e0	4d 8b cf	 mov	 r9, r15

; 219  :                             if (wnext < len) {  /* some from start of window */

  002e3	45 3b f2	 cmp	 r14d, r10d
  002e6	73 53		 jae	 SHORT $LN69@inflate_fa

; 220  :                                 op = wnext;

  002e8	41 8b ce	 mov	 ecx, r14d

; 221  :                                 len -= op;

  002eb	45 2b d6	 sub	 r10d, r14d
  002ee	66 90		 npad	 2
$LL13@inflate_fa:

; 222  :                                 do {
; 223  :                                     *out++ = *from++;

  002f0	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  002f4	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  002f8	41 88 00	 mov	 BYTE PTR [r8], al
  002fb	49 ff c0	 inc	 r8

; 224  :                                 } while (--op);

  002fe	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00301	75 ed		 jne	 SHORT $LL13@inflate_fa

; 225  :                                 from = out - dist;      /* rest from output */
; 226  :                             }
; 227  :                         }
; 228  :                     }

  00303	eb 2e		 jmp	 SHORT $LN104@inflate_fa
$LN41@inflate_fa:

; 229  :                     else {                      /* contiguous in window */
; 230  :                         from += wnext - op;

  00305	44 8b c8	 mov	 r9d, eax
  00308	4d 03 cf	 add	 r9, r15

; 231  :                         if (op < len) {         /* some from window */

  0030b	41 3b ca	 cmp	 ecx, r10d
  0030e	73 2b		 jae	 SHORT $LN69@inflate_fa

; 232  :                             len -= op;

  00310	44 2b d1	 sub	 r10d, ecx
  00313	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL16@inflate_fa:

; 233  :                             do {
; 234  :                                 *out++ = *from++;

  00320	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00324	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00328	41 88 00	 mov	 BYTE PTR [r8], al
  0032b	49 ff c0	 inc	 r8

; 235  :                             } while (--op);

  0032e	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00331	75 ed		 jne	 SHORT $LL16@inflate_fa
$LN104@inflate_fa:

; 236  :                             from = out - dist;  /* rest from output */
; 237  :                         }
; 238  :                     }
; 239  :                     while (len > 2) {

  00333	8b c2		 mov	 eax, edx
  00335	4d 8b c8	 mov	 r9, r8
  00338	4c 2b c8	 sub	 r9, rax
$LN69@inflate_fa:
  0033b	41 83 fa 02	 cmp	 r10d, 2
  0033f	76 49		 jbe	 SHORT $LN18@inflate_fa
  00341	41 8d 4a fd	 lea	 ecx, DWORD PTR [r10-3]
  00345	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0034a	f7 e1		 mul	 ecx
  0034c	d1 ea		 shr	 edx, 1
  0034e	8d 4a 01	 lea	 ecx, DWORD PTR [rdx+1]
  00351	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL17@inflate_fa:

; 240  :                         *out++ = *from++;

  00360	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 241  :                         *out++ = *from++;
; 242  :                         *out++ = *from++;
; 243  :                         len -= 3;

  00364	41 83 c2 fd	 add	 r10d, -3		; fffffffdH
  00368	41 88 00	 mov	 BYTE PTR [r8], al
  0036b	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00370	41 88 40 01	 mov	 BYTE PTR [r8+1], al
  00374	41 0f b6 41 02	 movzx	 eax, BYTE PTR [r9+2]
  00379	49 83 c1 03	 add	 r9, 3
  0037d	41 88 40 02	 mov	 BYTE PTR [r8+2], al
  00381	49 83 c0 03	 add	 r8, 3
  00385	48 2b cd	 sub	 rcx, rbp
  00388	75 d6		 jne	 SHORT $LL17@inflate_fa
$LN18@inflate_fa:

; 244  :                     }
; 245  :                     if (len) {

  0038a	45 85 d2	 test	 r10d, r10d
  0038d	74 7d		 je	 SHORT $LN101@inflate_fa

; 246  :                         *out++ = *from++;

  0038f	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 247  :                         if (len > 1)

  00393	48 8b 7c 24 08	 mov	 rdi, QWORD PTR dcode$1$[rsp]
  00398	41 88 00	 mov	 BYTE PTR [r8], al
  0039b	49 ff c0	 inc	 r8
  0039e	44 3b d5	 cmp	 r10d, ebp
  003a1	76 6e		 jbe	 SHORT $LN2@inflate_fa

; 248  :                             *out++ = *from++;

  003a3	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  003a8	41 88 00	 mov	 BYTE PTR [r8], al
  003ab	49 ff c0	 inc	 r8

; 249  :                     }
; 250  :                 }

  003ae	eb 61		 jmp	 SHORT $LN2@inflate_fa
$LN34@inflate_fa:

; 251  :                 else {
; 252  :                     from = out - dist;          /* copy direct from output */

  003b0	8b c2		 mov	 eax, edx
  003b2	49 8b c8	 mov	 rcx, r8
  003b5	48 2b c8	 sub	 rcx, rax
  003b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL21@inflate_fa:

; 253  :                     do {                        /* minimum length is three */
; 254  :                         *out++ = *from++;

  003c0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 255  :                         *out++ = *from++;
; 256  :                         *out++ = *from++;

  003c3	48 8d 49 03	 lea	 rcx, QWORD PTR [rcx+3]
  003c7	41 88 00	 mov	 BYTE PTR [r8], al

; 257  :                         len -= 3;

  003ca	41 83 c2 fd	 add	 r10d, -3		; fffffffdH
  003ce	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  003d2	41 88 40 01	 mov	 BYTE PTR [r8+1], al
  003d6	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  003da	41 88 40 02	 mov	 BYTE PTR [r8+2], al
  003de	49 83 c0 03	 add	 r8, 3

; 258  :                     } while (len > 2);

  003e2	41 83 fa 02	 cmp	 r10d, 2
  003e6	77 d8		 ja	 SHORT $LL21@inflate_fa

; 259  :                     if (len) {

  003e8	45 85 d2	 test	 r10d, r10d
  003eb	74 1f		 je	 SHORT $LN101@inflate_fa

; 260  :                         *out++ = *from++;

  003ed	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 261  :                         if (len > 1)

  003f0	48 8b 7c 24 08	 mov	 rdi, QWORD PTR dcode$1$[rsp]
  003f5	41 88 00	 mov	 BYTE PTR [r8], al
  003f8	49 ff c0	 inc	 r8
  003fb	44 3b d5	 cmp	 r10d, ebp
  003fe	76 11		 jbe	 SHORT $LN2@inflate_fa

; 262  :                             *out++ = *from++;

  00400	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00404	41 88 00	 mov	 BYTE PTR [r8], al
  00407	49 ff c0	 inc	 r8
  0040a	eb 05		 jmp	 SHORT $LN2@inflate_fa
$LN101@inflate_fa:

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  0040c	48 8b 7c 24 08	 mov	 rdi, QWORD PTR dcode$1$[rsp]
$LN2@inflate_fa:
  00411	48 3b 74 24 10	 cmp	 rsi, QWORD PTR last$1$[rsp]
  00416	73 61		 jae	 SHORT $LN103@inflate_fa
  00418	4c 3b 44 24 18	 cmp	 r8, QWORD PTR end$1$[rsp]
  0041d	73 5a		 jae	 SHORT $LN103@inflate_fa
  0041f	8b 14 24	 mov	 edx, DWORD PTR tv1185[rsp]
  00422	e9 7d fc ff ff	 jmp	 $LL4@inflate_fa
$LN52@inflate_fa:

; 278  :             goto dolen;
; 279  :         }
; 280  :         else if (op & 32) {                     /* end-of-block */

  00427	f6 c2 20	 test	 dl, 32			; 00000020H
  0042a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00432	74 0a		 je	 SHORT $LN54@inflate_fa

; 281  :             Tracevv((stderr, "inflate:         end of block\n"));
; 282  :             state->mode = TYPE;

  00434	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH

; 283  :             break;

  0043c	eb 43		 jmp	 SHORT $LN3@inflate_fa
$LN54@inflate_fa:

; 284  :         }
; 285  :         else {
; 286  :             strm->msg = (char *)"invalid literal/length code";

  0043e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  00445	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 287  :             state->mode = BAD;

  00449	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00451	eb 2e		 jmp	 SHORT $LN3@inflate_fa
$LN50@inflate_fa:

; 268  :                 goto dodist;
; 269  :             }
; 270  :             else {
; 271  :                 strm->msg = (char *)"invalid distance code";

  00453	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
$LN105@inflate_fa:

; 291  : 
; 292  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 293  :     len = bits >> 3;

  0045a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00462	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax
  00466	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  0046e	eb 11		 jmp	 SHORT $LN3@inflate_fa
$LN75@inflate_fa:

; 174  :                             strm->msg =

  00470	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  00477	eb e1		 jmp	 SHORT $LN105@inflate_fa
$LN103@inflate_fa:

; 291  : 
; 292  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 293  :     len = bits >> 3;

  00479	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
$LN3@inflate_fa:
  00481	41 8b cb	 mov	 ecx, r11d

; 294  :     in -= len;
; 295  :     bits -= len << 3;
; 296  :     hold &= (1U << bits) - 1;
; 297  : 
; 298  :     /* update state and return */
; 299  :     strm->next_in = in;
; 300  :     strm->next_out = out;

  00484	4c 89 42 10	 mov	 QWORD PTR [rdx+16], r8
  00488	c1 e9 03	 shr	 ecx, 3
  0048b	8b c1		 mov	 eax, ecx
  0048d	48 2b f0	 sub	 rsi, rax
  00490	48 89 32	 mov	 QWORD PTR [rdx], rsi
  00493	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [rcx*8]
  0049a	44 2b d8	 sub	 r11d, eax

; 301  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  0049d	48 8b 44 24 10	 mov	 rax, QWORD PTR last$1$[rsp]
  004a2	2b c6		 sub	 eax, esi
  004a4	41 8b cb	 mov	 ecx, r11d
  004a7	83 c0 05	 add	 eax, 5
  004aa	d3 e5		 shl	 ebp, cl
  004ac	89 42 08	 mov	 DWORD PTR [rdx+8], eax
  004af	ff cd		 dec	 ebp

; 302  :     strm->avail_out = (unsigned)(out < end ?

  004b1	48 8b 44 24 18	 mov	 rax, QWORD PTR end$1$[rsp]
  004b6	41 2b c0	 sub	 eax, r8d
  004b9	05 01 01 00 00	 add	 eax, 257		; 00000101H
  004be	89 42 18	 mov	 DWORD PTR [rdx+24], eax
  004c1	23 eb		 and	 ebp, ebx

; 303  :                                  257 + (end - out) : 257 - (out - end));
; 304  :     state->hold = hold;

  004c3	41 89 6d 48	 mov	 DWORD PTR [r13+72], ebp

; 305  :     state->bits = bits;

  004c7	45 89 5d 4c	 mov	 DWORD PTR [r13+76], r11d

; 306  :     return;
; 307  : }

  004cb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  004cf	41 5f		 pop	 r15
  004d1	41 5e		 pop	 r14
  004d3	41 5d		 pop	 r13
  004d5	41 5c		 pop	 r12
  004d7	5f		 pop	 rdi
  004d8	5e		 pop	 rsi
  004d9	5d		 pop	 rbp
  004da	5b		 pop	 rbx
  004db	c3		 ret	 0
inflate_fast ENDP
_TEXT	ENDS
END
