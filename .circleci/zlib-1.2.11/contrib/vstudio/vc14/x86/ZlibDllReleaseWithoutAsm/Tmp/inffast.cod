; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31107.0 

	TITLE	c:\cpython\externals\zlib-1.2.11\contrib\vstudio\vc14\x86\zlibdllreleasewithoutasm\tmp\inffast.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_fast
; Function compile flags: /Ogtp
; File C:\cpython\externals\zlib-1.2.11\inffast.c
;	COMDAT _inflate_fast
_TEXT	SEGMENT
_whave$1$ = -68						; size = 4
_beg$1$ = -64						; size = 4
_end$1$ = -60						; size = 4
_last$1$ = -56						; size = 4
_window$1$ = -52					; size = 4
_wsize$1$ = -48						; size = 4
_dcode$1$ = -44						; size = 4
_lcode$1$ = -40						; size = 4
_wnext$1$ = -36						; size = 4
_dmask$1$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -28						; size = 4
_bits$1$ = -28						; size = 4
_lmask$1$ = -24						; size = 4
_state$1$ = -20						; size = 4
_strm$1$ = -16						; size = 4
_dist$1$ = -12						; size = 4
_hold$1$ = -8						; size = 4
_in$1$ = -4						; size = 4
_inflate_fast PROC					; COMDAT
; _strm$ = ecx
; _start$ = edx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	89 7d f0	 mov	 DWORD PTR _strm$1$[ebp], edi

; 54   :     struct inflate_state FAR *state;
; 55   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 56   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 57   :     unsigned char FAR *out;     /* local strm->next_out */
; 58   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 59   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 60   : #ifdef INFLATE_STRICT
; 61   :     unsigned dmax;              /* maximum distance from zlib header */
; 62   : #endif
; 63   :     unsigned wsize;             /* window size or zero if not using window */
; 64   :     unsigned whave;             /* valid bytes in the window */
; 65   :     unsigned wnext;             /* window write index */
; 66   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 67   :     unsigned long hold;         /* local strm->hold */
; 68   :     unsigned bits;              /* local strm->bits */
; 69   :     code const FAR *lcode;      /* local strm->lencode */
; 70   :     code const FAR *dcode;      /* local strm->distcode */
; 71   :     unsigned lmask;             /* mask for first level of length codes */
; 72   :     unsigned dmask;             /* mask for first level of distance codes */
; 73   :     code here;                  /* retrieved table entry */
; 74   :     unsigned op;                /* code bits, operation, extra bits, or */
; 75   :                                 /*  window position, window bytes to copy */
; 76   :     unsigned len;               /* match length, unused bytes */
; 77   :     unsigned dist;              /* match distance */
; 78   :     unsigned char FAR *from;    /* where to copy match from */
; 79   : 
; 80   :     /* copy state to local variables */
; 81   :     state = (struct inflate_state FAR *)strm->state;

  0000e	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]

; 82   :     in = strm->next_in;
; 83   :     last = in + (strm->avail_in - 5);

  00011	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00014	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00016	83 c0 fb	 add	 eax, -5			; fffffffbH

; 84   :     out = strm->next_out;

  00019	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  0001c	03 c3		 add	 eax, ebx
  0001e	89 45 c8	 mov	 DWORD PTR _last$1$[ebp], eax

; 85   :     beg = out - (start - strm->avail_out);

  00021	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00024	8b f8		 mov	 edi, eax

; 86   :     end = out + (strm->avail_out - 257);

  00026	05 ff fe ff ff	 add	 eax, -257		; fffffeffH
  0002b	89 4d ec	 mov	 DWORD PTR _state$1$[ebp], ecx
  0002e	03 c6		 add	 eax, esi
  00030	89 5d fc	 mov	 DWORD PTR _in$1$[ebp], ebx
  00033	89 45 c4	 mov	 DWORD PTR _end$1$[ebp], eax
  00036	2b fa		 sub	 edi, edx

; 87   : #ifdef INFLATE_STRICT
; 88   :     dmax = state->dmax;
; 89   : #endif
; 90   :     wsize = state->wsize;

  00038	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0003b	03 fe		 add	 edi, esi

; 91   :     whave = state->whave;
; 92   :     wnext = state->wnext;
; 93   :     window = state->window;
; 94   :     hold = state->hold;

  0003d	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00040	89 45 d0	 mov	 DWORD PTR _wsize$1$[ebp], eax
  00043	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00046	89 45 bc	 mov	 DWORD PTR _whave$1$[ebp], eax
  00049	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0004c	89 45 dc	 mov	 DWORD PTR _wnext$1$[ebp], eax
  0004f	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00052	89 45 cc	 mov	 DWORD PTR _window$1$[ebp], eax

; 95   :     bits = state->bits;
; 96   :     lcode = state->lencode;

  00055	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00058	89 45 d8	 mov	 DWORD PTR _lcode$1$[ebp], eax

; 97   :     dcode = state->distcode;

  0005b	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0005e	89 45 d4	 mov	 DWORD PTR _dcode$1$[ebp], eax

; 98   :     lmask = (1U << state->lenbits) - 1;

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	89 45 e8	 mov	 DWORD PTR _lmask$1$[ebp], eax

; 99   :     dmask = (1U << state->distbits) - 1;

  00069	89 45 e0	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0006c	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  0006f	89 7d c0	 mov	 DWORD PTR _beg$1$[ebp], edi
  00072	8b 79 40	 mov	 edi, DWORD PTR [ecx+64]
  00075	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00078	d3 65 e8	 shl	 DWORD PTR _lmask$1$[ebp], cl
  0007b	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0007e	8b 45 e0	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  00081	ff 4d e8	 dec	 DWORD PTR _lmask$1$[ebp]
  00084	d3 e0		 shl	 eax, cl
  00086	48		 dec	 eax
  00087	89 45 e0	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL4@inflate_fa:

; 100  : 
; 101  :     /* decode literals and length/distances until end-of-block or not enough
; 102  :        input data or output space */
; 103  :     do {
; 104  :         if (bits < 15) {

  00090	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00093	73 1d		 jae	 SHORT $LN22@inflate_fa

; 105  :             hold += (unsigned long)(*in++) << bits;

  00095	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00098	8b cf		 mov	 ecx, edi
  0009a	d3 e0		 shl	 eax, cl

; 106  :             bits += 8;
; 107  :             hold += (unsigned long)(*in++) << bits;

  0009c	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0009f	03 d0		 add	 edx, eax
  000a1	0f b6 43 01	 movzx	 eax, BYTE PTR [ebx+1]
  000a5	d3 e0		 shl	 eax, cl
  000a7	83 c3 02	 add	 ebx, 2
  000aa	03 d0		 add	 edx, eax
  000ac	89 5d fc	 mov	 DWORD PTR _in$1$[ebp], ebx

; 108  :             bits += 8;

  000af	83 c7 10	 add	 edi, 16			; 00000010H
$LN22@inflate_fa:

; 109  :         }
; 110  :         here = lcode[hold & lmask];

  000b2	8b 45 e8	 mov	 eax, DWORD PTR _lmask$1$[ebp]
  000b5	8b 4d d8	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000b8	23 c2		 and	 eax, edx
  000ba	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000bd	8b c8		 mov	 ecx, eax
  000bf	c1 e9 08	 shr	 ecx, 8
  000c2	0f b6 c9	 movzx	 ecx, cl

; 111  :       dolen:
; 112  :         op = (unsigned)(here.bits);
; 113  :         hold >>= op;

  000c5	d3 ea		 shr	 edx, cl

; 114  :         bits -= op;

  000c7	2b f9		 sub	 edi, ecx
  000c9	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  000cc	0f b6 d0	 movzx	 edx, al

; 115  :         op = (unsigned)(here.op);
; 116  :         if (op == 0) {                          /* literal */

  000cf	84 c0		 test	 al, al
  000d1	74 54		 je	 SHORT $LN72@inflate_fa
  000d3	c1 e8 10	 shr	 eax, 16			; 00000010H
  000d6	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  000d9	8b d8		 mov	 ebx, eax
  000db	0f 1f 44 00 00	 npad	 5
$dolen$108:

; 121  :         }
; 122  :         else if (op & 16) {                     /* length base */

  000e0	f6 c2 10	 test	 dl, 16			; 00000010H
  000e3	75 4d		 jne	 SHORT $LN73@inflate_fa

; 274  :             }
; 275  :         }
; 276  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000e5	f6 c2 40	 test	 dl, 64			; 00000040H
  000e8	0f 85 c5 02 00
	00		 jne	 $LN52@inflate_fa

; 277  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  000ee	8b ca		 mov	 ecx, edx
  000f0	b8 01 00 00 00	 mov	 eax, 1
  000f5	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  000f8	d3 e0		 shl	 eax, cl
  000fa	8b 4d d8	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000fd	48		 dec	 eax
  000fe	23 c2		 and	 eax, edx
  00100	03 45 e4	 add	 eax, DWORD PTR $T2[ebp]
  00103	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00106	8b d8		 mov	 ebx, eax
  00108	8b cb		 mov	 ecx, ebx
  0010a	c1 e9 08	 shr	 ecx, 8
  0010d	0f b6 c9	 movzx	 ecx, cl
  00110	d3 ea		 shr	 edx, cl
  00112	2b f9		 sub	 edi, ecx
  00114	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00117	0f b6 d3	 movzx	 edx, bl
  0011a	c1 eb 10	 shr	 ebx, 16			; 00000010H
  0011d	89 5d e4	 mov	 DWORD PTR $T2[ebp], ebx
  00120	85 d2		 test	 edx, edx
  00122	75 bc		 jne	 SHORT $dolen$108

; 115  :         op = (unsigned)(here.op);
; 116  :         if (op == 0) {                          /* literal */

  00124	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
$LN72@inflate_fa:

; 117  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 118  :                     "inflate:         literal '%c'\n" :
; 119  :                     "inflate:         literal 0x%02x\n", here.val));
; 120  :             *out++ = (unsigned char)(here.val);

  00127	c1 e8 10	 shr	 eax, 16			; 00000010H
  0012a	88 06		 mov	 BYTE PTR [esi], al
  0012c	46		 inc	 esi

; 244  :                     }
; 245  :                     if (len) {

  0012d	e9 6f 02 00 00	 jmp	 $LN2@inflate_fa
$LN73@inflate_fa:

; 123  :             len = (unsigned)(here.val);
; 124  :             op &= 15;                           /* number of extra bits */

  00132	83 e2 0f	 and	 edx, 15			; 0000000fH

; 125  :             if (op) {

  00135	74 2b		 je	 SHORT $LN27@inflate_fa

; 126  :                 if (bits < op) {

  00137	3b fa		 cmp	 edi, edx
  00139	73 13		 jae	 SHORT $LN28@inflate_fa

; 127  :                     hold += (unsigned long)(*in++) << bits;

  0013b	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  0013e	8b cf		 mov	 ecx, edi
  00140	ff 45 fc	 inc	 DWORD PTR _in$1$[ebp]
  00143	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00146	d3 e0		 shl	 eax, cl
  00148	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax

; 128  :                     bits += 8;

  0014b	83 c7 08	 add	 edi, 8
$LN28@inflate_fa:

; 129  :                 }
; 130  :                 len += (unsigned)hold & ((1U << op) - 1);

  0014e	8b ca		 mov	 ecx, edx
  00150	b8 01 00 00 00	 mov	 eax, 1
  00155	d3 e0		 shl	 eax, cl
  00157	48		 dec	 eax
  00158	23 45 f8	 and	 eax, DWORD PTR _hold$1$[ebp]

; 131  :                 hold >>= op;

  0015b	d3 6d f8	 shr	 DWORD PTR _hold$1$[ebp], cl
  0015e	03 d8		 add	 ebx, eax

; 132  :                 bits -= op;

  00160	2b fa		 sub	 edi, edx
$LN27@inflate_fa:

; 133  :             }
; 134  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 135  :             if (bits < 15) {

  00162	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00165	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00168	73 26		 jae	 SHORT $LN29@inflate_fa

; 136  :                 hold += (unsigned long)(*in++) << bits;

  0016a	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  0016d	8b cf		 mov	 ecx, edi
  0016f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00172	d3 e0		 shl	 eax, cl

; 137  :                 bits += 8;
; 138  :                 hold += (unsigned long)(*in++) << bits;

  00174	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00177	03 d0		 add	 edx, eax
  00179	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  0017c	40		 inc	 eax
  0017d	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  00180	ff 45 fc	 inc	 DWORD PTR _in$1$[ebp]
  00183	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00186	d3 e0		 shl	 eax, cl
  00188	03 d0		 add	 edx, eax

; 139  :                 bits += 8;

  0018a	83 c7 10	 add	 edi, 16			; 00000010H
  0018d	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
$LN29@inflate_fa:

; 140  :             }
; 141  :             here = dcode[hold & dmask];

  00190	8b 45 e0	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  00193	8b 4d d4	 mov	 ecx, DWORD PTR _dcode$1$[ebp]
  00196	23 c2		 and	 eax, edx
  00198	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0019b	8b c2		 mov	 eax, edx
  0019d	c1 e8 10	 shr	 eax, 16			; 00000010H
  001a0	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  001a3	8b c2		 mov	 eax, edx
  001a5	c1 e8 08	 shr	 eax, 8
  001a8	0f b6 c8	 movzx	 ecx, al

; 142  :           dodist:
; 143  :             op = (unsigned)(here.bits);
; 144  :             hold >>= op;

  001ab	8b 45 f8	 mov	 eax, DWORD PTR _hold$1$[ebp]

; 145  :             bits -= op;

  001ae	2b f9		 sub	 edi, ecx
  001b0	d3 e8		 shr	 eax, cl
  001b2	0f b6 d2	 movzx	 edx, dl
  001b5	89 45 f8	 mov	 DWORD PTR _hold$1$[ebp], eax

; 146  :             op = (unsigned)(here.op);
; 147  :             if (op & 16) {                      /* distance base */

  001b8	f6 c2 10	 test	 dl, 16			; 00000010H
  001bb	75 47		 jne	 SHORT $LN74@inflate_fa

; 115  :         op = (unsigned)(here.op);
; 116  :         if (op == 0) {                          /* literal */

  001bd	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  001c0	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
$dodist$109:

; 263  :                     }
; 264  :                 }
; 265  :             }
; 266  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001c3	f6 c2 40	 test	 dl, 64			; 00000040H
  001c6	0f 85 0e 02 00
	00		 jne	 $LN50@inflate_fa

; 267  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  001cc	8b ca		 mov	 ecx, edx
  001ce	b8 01 00 00 00	 mov	 eax, 1
  001d3	d3 e0		 shl	 eax, cl
  001d5	8b 4d d4	 mov	 ecx, DWORD PTR _dcode$1$[ebp]
  001d8	48		 dec	 eax
  001d9	23 45 f8	 and	 eax, DWORD PTR _hold$1$[ebp]
  001dc	03 45 e4	 add	 eax, DWORD PTR $T1[ebp]
  001df	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  001e2	8b c2		 mov	 eax, edx
  001e4	c1 e8 10	 shr	 eax, 16			; 00000010H
  001e7	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  001ea	8b c2		 mov	 eax, edx
  001ec	c1 e8 08	 shr	 eax, 8
  001ef	0f b6 c8	 movzx	 ecx, al
  001f2	8b 45 f8	 mov	 eax, DWORD PTR _hold$1$[ebp]
  001f5	2b f9		 sub	 edi, ecx
  001f7	d3 e8		 shr	 eax, cl
  001f9	0f b6 d2	 movzx	 edx, dl
  001fc	89 45 f8	 mov	 DWORD PTR _hold$1$[ebp], eax
  001ff	f6 c2 10	 test	 dl, 16			; 00000010H
  00202	74 bf		 je	 SHORT $dodist$109
$LN74@inflate_fa:

; 148  :                 dist = (unsigned)(here.val);
; 149  :                 op &= 15;                       /* number of extra bits */

  00204	83 e2 0f	 and	 edx, 15			; 0000000fH

; 150  :                 if (bits < op) {

  00207	3b fa		 cmp	 edi, edx
  00209	73 2e		 jae	 SHORT $LN33@inflate_fa

; 151  :                     hold += (unsigned long)(*in++) << bits;

  0020b	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  0020e	8b cf		 mov	 ecx, edi

; 152  :                     bits += 8;

  00210	83 c7 08	 add	 edi, 8
  00213	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00216	d3 e0		 shl	 eax, cl
  00218	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  0021b	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  0021e	40		 inc	 eax
  0021f	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax

; 153  :                     if (bits < op) {

  00222	3b fa		 cmp	 edi, edx
  00224	73 10		 jae	 SHORT $LN101@inflate_fa

; 154  :                         hold += (unsigned long)(*in++) << bits;

  00226	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00229	8b cf		 mov	 ecx, edi
  0022b	ff 45 fc	 inc	 DWORD PTR _in$1$[ebp]
  0022e	d3 e0		 shl	 eax, cl
  00230	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax

; 155  :                         bits += 8;

  00233	83 c7 08	 add	 edi, 8
$LN101@inflate_fa:

; 156  :                     }
; 157  :                 }
; 158  :                 dist += (unsigned)hold & ((1U << op) - 1);

  00236	8b 45 f8	 mov	 eax, DWORD PTR _hold$1$[ebp]
$LN33@inflate_fa:
  00239	8b ca		 mov	 ecx, edx
  0023b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _dist$1$[ebp], 1
  00242	d3 65 f4	 shl	 DWORD PTR _dist$1$[ebp], cl

; 159  : #ifdef INFLATE_STRICT
; 160  :                 if (dist > dmax) {
; 161  :                     strm->msg = (char *)"invalid distance too far back";
; 162  :                     state->mode = BAD;
; 163  :                     break;
; 164  :                 }
; 165  : #endif
; 166  :                 hold >>= op;
; 167  :                 bits -= op;

  00245	2b fa		 sub	 edi, edx
  00247	8b 4d f4	 mov	 ecx, DWORD PTR _dist$1$[ebp]
  0024a	49		 dec	 ecx
  0024b	23 c8		 and	 ecx, eax
  0024d	03 4d e4	 add	 ecx, DWORD PTR $T1[ebp]
  00250	89 4d f4	 mov	 DWORD PTR _dist$1$[ebp], ecx
  00253	8b ca		 mov	 ecx, edx

; 168  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 169  :                 op = (unsigned)(out - beg);     /* max distance in output */
; 170  :                 if (dist > op) {                /* see if copy from window */

  00255	8b 55 f4	 mov	 edx, DWORD PTR _dist$1$[ebp]
  00258	d3 e8		 shr	 eax, cl
  0025a	89 45 f8	 mov	 DWORD PTR _hold$1$[ebp], eax
  0025d	8b c6		 mov	 eax, esi
  0025f	2b 45 c0	 sub	 eax, DWORD PTR _beg$1$[ebp]
  00262	89 7d e4	 mov	 DWORD PTR _bits$1$[ebp], edi
  00265	3b d0		 cmp	 edx, eax
  00267	0f 86 f0 00 00
	00		 jbe	 $LN34@inflate_fa

; 171  :                     op = dist - op;             /* distance back in window */

  0026d	8b ca		 mov	 ecx, edx
  0026f	2b c8		 sub	 ecx, eax

; 172  :                     if (op > whave) {

  00271	3b 4d bc	 cmp	 ecx, DWORD PTR _whave$1$[ebp]
  00274	76 10		 jbe	 SHORT $LN37@inflate_fa

; 173  :                         if (state->sane) {

  00276	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  00279	83 b8 c4 1b 00
	00 00		 cmp	 DWORD PTR [eax+7108], 0
  00280	0f 85 6d 01 00
	00		 jne	 $LN75@inflate_fa
$LN37@inflate_fa:

; 177  :                             break;
; 178  :                         }
; 179  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 180  :                         if (len <= op - whave) {
; 181  :                             do {
; 182  :                                 *out++ = 0;
; 183  :                             } while (--len);
; 184  :                             continue;
; 185  :                         }
; 186  :                         len -= op - whave;
; 187  :                         do {
; 188  :                             *out++ = 0;
; 189  :                         } while (--op > whave);
; 190  :                         if (op == 0) {
; 191  :                             from = out - dist;
; 192  :                             do {
; 193  :                                 *out++ = *from++;
; 194  :                             } while (--len);
; 195  :                             continue;
; 196  :                         }
; 197  : #endif
; 198  :                     }
; 199  :                     from = window;

  00286	8b 45 cc	 mov	 eax, DWORD PTR _window$1$[ebp]

; 200  :                     if (wnext == 0) {           /* very common case */

  00289	8b 7d dc	 mov	 edi, DWORD PTR _wnext$1$[ebp]
  0028c	2b c1		 sub	 eax, ecx
  0028e	85 ff		 test	 edi, edi
  00290	75 1d		 jne	 SHORT $LN38@inflate_fa

; 201  :                         from += wsize - op;

  00292	8b 7d d0	 mov	 edi, DWORD PTR _wsize$1$[ebp]
  00295	03 f8		 add	 edi, eax

; 202  :                         if (op < len) {         /* some from window */

  00297	3b cb		 cmp	 ecx, ebx
  00299	73 6c		 jae	 SHORT $LN69@inflate_fa

; 203  :                             len -= op;

  0029b	2b d9		 sub	 ebx, ecx
  0029d	0f 1f 00	 npad	 3
$LL7@inflate_fa:

; 204  :                             do {
; 205  :                                 *out++ = *from++;

  002a0	8a 07		 mov	 al, BYTE PTR [edi]
  002a2	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002a5	88 06		 mov	 BYTE PTR [esi], al
  002a7	46		 inc	 esi

; 206  :                             } while (--op);

  002a8	83 e9 01	 sub	 ecx, 1
  002ab	75 f3		 jne	 SHORT $LL7@inflate_fa

; 207  :                             from = out - dist;  /* rest from output */
; 208  :                         }
; 209  :                     }

  002ad	eb 54		 jmp	 SHORT $LN106@inflate_fa
$LN38@inflate_fa:

; 210  :                     else if (wnext < op) {      /* wrap around window */

  002af	03 f8		 add	 edi, eax
  002b1	8b 45 dc	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  002b4	3b c1		 cmp	 eax, ecx
  002b6	73 38		 jae	 SHORT $LN41@inflate_fa

; 211  :                         from += wsize + wnext - op;

  002b8	03 7d d0	 add	 edi, DWORD PTR _wsize$1$[ebp]

; 212  :                         op -= wnext;

  002bb	2b c8		 sub	 ecx, eax

; 213  :                         if (op < len) {         /* some from end of window */

  002bd	8b 55 f4	 mov	 edx, DWORD PTR _dist$1$[ebp]
  002c0	3b cb		 cmp	 ecx, ebx
  002c2	73 43		 jae	 SHORT $LN69@inflate_fa

; 214  :                             len -= op;

  002c4	2b d9		 sub	 ebx, ecx
  002c6	2b fe		 sub	 edi, esi
$LL10@inflate_fa:

; 215  :                             do {
; 216  :                                 *out++ = *from++;

  002c8	8a 04 37	 mov	 al, BYTE PTR [edi+esi]
  002cb	88 06		 mov	 BYTE PTR [esi], al
  002cd	46		 inc	 esi

; 217  :                             } while (--op);

  002ce	83 e9 01	 sub	 ecx, 1
  002d1	75 f5		 jne	 SHORT $LL10@inflate_fa

; 218  :                             from = window;
; 219  :                             if (wnext < len) {  /* some from start of window */

  002d3	8b 45 dc	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  002d6	8b 7d cc	 mov	 edi, DWORD PTR _window$1$[ebp]
  002d9	3b c3		 cmp	 eax, ebx
  002db	73 2a		 jae	 SHORT $LN69@inflate_fa

; 220  :                                 op = wnext;

  002dd	8b c8		 mov	 ecx, eax

; 221  :                                 len -= op;

  002df	2b d8		 sub	 ebx, eax
$LL13@inflate_fa:

; 222  :                                 do {
; 223  :                                     *out++ = *from++;

  002e1	8a 07		 mov	 al, BYTE PTR [edi]
  002e3	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002e6	88 06		 mov	 BYTE PTR [esi], al
  002e8	46		 inc	 esi

; 224  :                                 } while (--op);

  002e9	83 e9 01	 sub	 ecx, 1
  002ec	75 f3		 jne	 SHORT $LL13@inflate_fa

; 225  :                                 from = out - dist;      /* rest from output */
; 226  :                             }
; 227  :                         }
; 228  :                     }

  002ee	eb 13		 jmp	 SHORT $LN106@inflate_fa
$LN41@inflate_fa:

; 229  :                     else {                      /* contiguous in window */
; 230  :                         from += wnext - op;
; 231  :                         if (op < len) {         /* some from window */

  002f0	3b cb		 cmp	 ecx, ebx
  002f2	73 13		 jae	 SHORT $LN69@inflate_fa

; 232  :                             len -= op;

  002f4	2b d9		 sub	 ebx, ecx
$LL16@inflate_fa:

; 233  :                             do {
; 234  :                                 *out++ = *from++;

  002f6	8a 07		 mov	 al, BYTE PTR [edi]
  002f8	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002fb	88 06		 mov	 BYTE PTR [esi], al
  002fd	46		 inc	 esi

; 235  :                             } while (--op);

  002fe	83 e9 01	 sub	 ecx, 1
  00301	75 f3		 jne	 SHORT $LL16@inflate_fa
$LN106@inflate_fa:

; 236  :                             from = out - dist;  /* rest from output */
; 237  :                         }
; 238  :                     }
; 239  :                     while (len > 2) {

  00303	8b fe		 mov	 edi, esi
  00305	2b fa		 sub	 edi, edx
$LN69@inflate_fa:
  00307	83 fb 02	 cmp	 ebx, 2
  0030a	76 35		 jbe	 SHORT $LN18@inflate_fa
  0030c	8d 4b fd	 lea	 ecx, DWORD PTR [ebx-3]
  0030f	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00314	f7 e1		 mul	 ecx
  00316	d1 ea		 shr	 edx, 1
  00318	42		 inc	 edx
  00319	0f 1f 80 00 00
	00 00		 npad	 7
$LL17@inflate_fa:

; 240  :                         *out++ = *from++;

  00320	0f b6 07	 movzx	 eax, BYTE PTR [edi]

; 241  :                         *out++ = *from++;
; 242  :                         *out++ = *from++;
; 243  :                         len -= 3;

  00323	83 eb 03	 sub	 ebx, 3
  00326	88 06		 mov	 BYTE PTR [esi], al
  00328	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  0032c	88 46 01	 mov	 BYTE PTR [esi+1], al
  0032f	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  00333	83 c7 03	 add	 edi, 3
  00336	88 46 02	 mov	 BYTE PTR [esi+2], al
  00339	83 c6 03	 add	 esi, 3
  0033c	83 ea 01	 sub	 edx, 1
  0033f	75 df		 jne	 SHORT $LL17@inflate_fa
$LN18@inflate_fa:

; 244  :                     }
; 245  :                     if (len) {

  00341	85 db		 test	 ebx, ebx
  00343	74 56		 je	 SHORT $LN98@inflate_fa

; 246  :                         *out++ = *from++;

  00345	8a 07		 mov	 al, BYTE PTR [edi]
  00347	88 06		 mov	 BYTE PTR [esi], al
  00349	46		 inc	 esi

; 247  :                         if (len > 1)

  0034a	83 fb 01	 cmp	 ebx, 1
  0034d	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00350	76 06		 jbe	 SHORT $LN99@inflate_fa

; 248  :                             *out++ = *from++;

  00352	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00355	88 06		 mov	 BYTE PTR [esi], al
  00357	46		 inc	 esi
$LN99@inflate_fa:

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  00358	8b 7d e4	 mov	 edi, DWORD PTR _bits$1$[ebp]
  0035b	eb 44		 jmp	 SHORT $LN2@inflate_fa
$LN34@inflate_fa:

; 249  :                     }
; 250  :                 }
; 251  :                 else {
; 252  :                     from = out - dist;          /* copy direct from output */

  0035d	8b ce		 mov	 ecx, esi
  0035f	2b ca		 sub	 ecx, edx
$LL21@inflate_fa:

; 253  :                     do {                        /* minimum length is three */
; 254  :                         *out++ = *from++;

  00361	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 255  :                         *out++ = *from++;
; 256  :                         *out++ = *from++;

  00364	8d 49 03	 lea	 ecx, DWORD PTR [ecx+3]
  00367	88 06		 mov	 BYTE PTR [esi], al

; 257  :                         len -= 3;

  00369	83 eb 03	 sub	 ebx, 3
  0036c	0f b6 41 fe	 movzx	 eax, BYTE PTR [ecx-2]
  00370	88 46 01	 mov	 BYTE PTR [esi+1], al
  00373	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  00377	88 46 02	 mov	 BYTE PTR [esi+2], al
  0037a	83 c6 03	 add	 esi, 3

; 258  :                     } while (len > 2);

  0037d	83 fb 02	 cmp	 ebx, 2
  00380	77 df		 ja	 SHORT $LL21@inflate_fa

; 259  :                     if (len) {

  00382	85 db		 test	 ebx, ebx
  00384	74 18		 je	 SHORT $LN103@inflate_fa

; 260  :                         *out++ = *from++;

  00386	8a 01		 mov	 al, BYTE PTR [ecx]
  00388	88 06		 mov	 BYTE PTR [esi], al
  0038a	46		 inc	 esi

; 261  :                         if (len > 1)

  0038b	83 fb 01	 cmp	 ebx, 1
  0038e	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00391	76 0e		 jbe	 SHORT $LN2@inflate_fa

; 262  :                             *out++ = *from++;

  00393	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00396	88 06		 mov	 BYTE PTR [esi], al
  00398	46		 inc	 esi
  00399	eb 06		 jmp	 SHORT $LN2@inflate_fa
$LN98@inflate_fa:

; 244  :                     }
; 245  :                     if (len) {

  0039b	8b 7d e4	 mov	 edi, DWORD PTR _bits$1$[ebp]
$LN103@inflate_fa:

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  0039e	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
$LN2@inflate_fa:
  003a1	3b 5d c8	 cmp	 ebx, DWORD PTR _last$1$[ebp]
  003a4	73 63		 jae	 SHORT $LN105@inflate_fa
  003a6	3b 75 c4	 cmp	 esi, DWORD PTR _end$1$[ebp]
  003a9	73 5e		 jae	 SHORT $LN105@inflate_fa
  003ab	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  003ae	e9 dd fc ff ff	 jmp	 $LL4@inflate_fa
$LN52@inflate_fa:

; 278  :             goto dolen;
; 279  :         }
; 280  :         else if (op & 32) {                     /* end-of-block */

  003b3	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  003b6	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  003b9	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]
  003bc	f6 c2 20	 test	 dl, 32			; 00000020H
  003bf	74 09		 je	 SHORT $LN54@inflate_fa

; 281  :             Tracevv((stderr, "inflate:         end of block\n"));
; 282  :             state->mode = TYPE;

  003c1	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH

; 283  :             break;

  003c8	eb 42		 jmp	 SHORT $LN3@inflate_fa
$LN54@inflate_fa:

; 284  :         }
; 285  :         else {
; 286  :             strm->msg = (char *)"invalid literal/length code";

  003ca	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 287  :             state->mode = BAD;

  003d1	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H
  003d8	eb 32		 jmp	 SHORT $LN3@inflate_fa
$LN50@inflate_fa:

; 268  :                 goto dodist;
; 269  :             }
; 270  :             else {
; 271  :                 strm->msg = (char *)"invalid distance code";

  003da	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]

; 272  :                 state->mode = BAD;

  003dd	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]

; 273  :                 break;

  003e0	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  003e3	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  003ea	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H
  003f1	eb 19		 jmp	 SHORT $LN3@inflate_fa
$LN75@inflate_fa:

; 174  :                             strm->msg =

  003f3	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]
  003f6	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  003f9	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 175  :                                 (char *)"invalid distance too far back";
; 176  :                             state->mode = BAD;

  00400	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  00407	eb 03		 jmp	 SHORT $LN3@inflate_fa
$LN105@inflate_fa:

; 291  : 
; 292  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 293  :     len = bits >> 3;

  00409	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]
$LN3@inflate_fa:
  0040c	8b c7		 mov	 eax, edi

; 294  :     in -= len;
; 295  :     bits -= len << 3;
; 296  :     hold &= (1U << bits) - 1;
; 297  : 
; 298  :     /* update state and return */
; 299  :     strm->next_in = in;
; 300  :     strm->next_out = out;

  0040e	89 71 0c	 mov	 DWORD PTR [ecx+12], esi
  00411	c1 e8 03	 shr	 eax, 3
  00414	2b d8		 sub	 ebx, eax
  00416	c1 e0 03	 shl	 eax, 3
  00419	2b f8		 sub	 edi, eax
  0041b	89 19		 mov	 DWORD PTR [ecx], ebx

; 301  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  0041d	8b 45 c8	 mov	 eax, DWORD PTR _last$1$[ebp]
  00420	2b c3		 sub	 eax, ebx
  00422	83 c0 05	 add	 eax, 5
  00425	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 302  :     strm->avail_out = (unsigned)(out < end ?

  00428	8b 45 c4	 mov	 eax, DWORD PTR _end$1$[ebp]
  0042b	2b c6		 sub	 eax, esi
  0042d	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00432	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00435	8b cf		 mov	 ecx, edi
  00437	b8 01 00 00 00	 mov	 eax, 1
  0043c	d3 e0		 shl	 eax, cl

; 303  :                                  257 + (end - out) : 257 - (out - end));
; 304  :     state->hold = hold;

  0043e	8b 4d ec	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00441	48		 dec	 eax
  00442	23 45 f8	 and	 eax, DWORD PTR _hold$1$[ebp]

; 305  :     state->bits = bits;

  00445	89 79 40	 mov	 DWORD PTR [ecx+64], edi
  00448	5f		 pop	 edi
  00449	5e		 pop	 esi
  0044a	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  0044d	5b		 pop	 ebx

; 306  :     return;
; 307  : }

  0044e	8b e5		 mov	 esp, ebp
  00450	5d		 pop	 ebp
  00451	c3		 ret	 0
_inflate_fast ENDP
_TEXT	ENDS
END
